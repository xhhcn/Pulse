---
import SystemTableHeader from './SystemTableHeader.astro';
import SystemTableHeaderRow from './SystemTableHeaderRow.astro';
import LoadingState from './LoadingState.astro';
import { Icon as AstroIcon } from 'astro-icon/components';

const { apiBase: apiBaseProp } = Astro.props ?? {};
const apiBase = apiBaseProp ?? '';
---

<div 
  id="monitor-root"
  data-api-base={apiBase}
  class="mx-auto mt-2 sm:mt-3 max-w-7xl rounded-xl border border-[#404040]/50 dark:border-[#404040]/50 border-[#a3a3a3]/50 bg-[#1c1c1c] dark:bg-[#1c1c1c] bg-white p-2 sm:p-4 md:p-6"
>
  <SystemTableHeader />

  <!-- 表格容器 - 独立边框 -->
  <div class="rounded-xl border border-[#404040]/50 dark:border-[#404040]/50 border-[#a3a3a3]/50 bg-[#181818] dark:bg-[#181818] bg-[#fafafa] overflow-x-auto" style="scrollbar-width: none; -ms-overflow-style: none;">
    <style>
      #monitor-root .overflow-x-auto::-webkit-scrollbar {
        display: none;
      }
    </style>
    <div class="min-w-[1000px]">
      <SystemTableHeaderRow />

      <!-- 表格主体 -->
      <div id="systems-body" class="divide-y divide-[#404040]/50 dark:divide-[#404040]/50 divide-[#e5e5e5]">
        <LoadingState />
      </div>
    </div>
  </div>
</div>

<script>
  // Import utility functions (inline for Astro compatibility)
  const getApiBase = (root) => {
    if (root?.dataset.apiBase && root.dataset.apiBase.trim() !== '') {
      return root.dataset.apiBase.trim();
    }
    // Use current origin (works with nginx reverse proxy)
    return window.location.origin;
  };

  // Helper function to get authentication info (share token or admin token)
  const getAuthInfo = () => {
    const urlParams = new URLSearchParams(window.location.search);
    const shareToken = urlParams.get('token');
    const adminToken = localStorage.getItem('admin_auth_token');
    return { shareToken, adminToken };
  };

  // Helper function to build authenticated fetch options
  const buildAuthOptions = (url) => {
    const { shareToken, adminToken } = getAuthInfo();
    let requestUrl = url;
    const headers = {};
    
    if (shareToken) {
      // Use share token from URL
      const separator = url.includes('?') ? '&' : '?';
      requestUrl += `${separator}token=${encodeURIComponent(shareToken)}`;
    } else if (adminToken) {
      // Use admin token in Authorization header
      headers['Authorization'] = `Bearer ${adminToken}`;
    }
    
    return { url: requestUrl, headers };
  };

  const fetchSystemMetrics = async (apiBase) => {
    // Build request URL with token if available
    let requestUrl = `${apiBase}/api/metrics`;
    const headers = { 'Cache-Control': 'no-store' };
    
    const { shareToken, adminToken } = getAuthInfo();
    if (shareToken) {
      // Use share token from URL
      requestUrl += `?token=${encodeURIComponent(shareToken)}`;
    } else if (adminToken) {
      // Use admin token in Authorization header
      headers['Authorization'] = `Bearer ${adminToken}`;
    }
    
    const res = await fetch(requestUrl, { 
      cache: 'no-store',
      headers: headers
    });
    if (!res.ok) {
      // If 401 Unauthorized, redirect to login page
      if (res.status === 401) {
        localStorage.removeItem('admin_auth_token');
        window.location.href = '/login?redirect=/';
        throw new Error('Unauthorized - redirecting to login');
      }
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    if (Array.isArray(data)) return data;
    if (data === null) return [];
    return [];
  };

  const setupCopyButtons = (container) => {
    if (!container || container.dataset.copySetup) return;
    container.addEventListener('click', async (e) => {
      const copyBtn = e.target.closest('.copy-btn');
      if (!copyBtn) return;
      e.stopPropagation();
      const systemName = copyBtn.dataset.systemName;
      if (systemName) {
        const success = await copyToClipboard(systemName);
        if (success) {
          const copyIcon = copyBtn.querySelector('.copy-icon');
          const checkIcon = copyBtn.querySelector('.check-icon');
          const originalTitle = copyBtn.title;
          if (copyIcon && checkIcon) {
            copyIcon.style.display = 'none';
            checkIcon.style.display = 'block';
            copyBtn.title = 'Copied!';
            setTimeout(() => {
              copyIcon.style.display = 'block';
              checkIcon.style.display = 'none';
              copyBtn.title = originalTitle;
            }, 1000);
          }
        }
      }
    });
    container.dataset.copySetup = 'true';
  };

  const copyToClipboard = async (text) => {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (err) {
      try {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        return true;
      } catch (fallbackErr) {
        return false;
      }
    }
  };

  // Country to flag icon mapping (emojione-v1)
  // Supports both ISO 3166-1 alpha-2 country codes (e.g., "US", "CN", "HK") and country names
  // Backend now returns ISO 3166-1 alpha-2 country codes
  // Format: emojione-v1:flag-for-{country-name} (e.g., emojione-v1:flag-for-afghanistan)
  const countryToFlag = (country) => {
    if (!country) return null;
    
    const countryTrimmed = country.trim();
    
    // ISO 3166-1 alpha-2 country code to country name mapping
    // Maps to emojione-v1 flag format: emojione-v1:flag-for-{country-name}
    const countryCodeToName = {
      'AD': 'andorra', 'AE': 'united-arab-emirates', 'AF': 'afghanistan', 'AG': 'antigua-and-barbuda',
      'AI': 'anguilla', 'AL': 'albania', 'AM': 'armenia', 'AO': 'angola', 'AQ': 'antarctica',
      'AR': 'argentina', 'AS': 'american-samoa', 'AT': 'austria', 'AU': 'australia', 'AW': 'aruba',
      'AX': 'aland-islands', 'AZ': 'azerbaijan', 'BA': 'bosnia-and-herzegovina', 'BB': 'barbados',
      'BD': 'bangladesh', 'BE': 'belgium', 'BF': 'burkina-faso', 'BG': 'bulgaria', 'BH': 'bahrain',
      'BI': 'burundi', 'BJ': 'benin', 'BL': 'saint-barthelemy', 'BM': 'bermuda', 'BN': 'brunei',
      'BO': 'bolivia', 'BQ': 'caribbean-netherlands', 'BR': 'brazil', 'BS': 'bahamas', 'BT': 'bhutan',
      'BV': 'bouvet-island', 'BW': 'botswana', 'BY': 'belarus', 'BZ': 'belize', 'CA': 'canada',
      'CC': 'cocos-islands', 'CD': 'congo-kinshasa', 'CF': 'central-african-republic', 'CG': 'congo-brazzaville',
      'CH': 'switzerland', 'CI': 'cote-divoire', 'CK': 'cook-islands', 'CL': 'chile', 'CM': 'cameroon',
      'CN': 'china', 'CO': 'colombia', 'CR': 'costa-rica', 'CU': 'cuba', 'CV': 'cape-verde',
      'CW': 'curacao', 'CX': 'christmas-island', 'CY': 'cyprus', 'CZ': 'czech-republic', 'DE': 'germany',
      'DJ': 'djibouti', 'DK': 'denmark', 'DM': 'dominica', 'DO': 'dominican-republic', 'DZ': 'algeria',
      'EC': 'ecuador', 'EE': 'estonia', 'EG': 'egypt', 'EH': 'western-sahara', 'ER': 'eritrea',
      'ES': 'spain', 'ET': 'ethiopia', 'FI': 'finland', 'FJ': 'fiji', 'FK': 'falkland-islands',
      'FM': 'micronesia', 'FO': 'faroe-islands', 'FR': 'france', 'GA': 'gabon', 'GB': 'united-kingdom',
      'GD': 'grenada', 'GE': 'georgia', 'GF': 'french-guiana', 'GG': 'guernsey', 'GH': 'ghana',
      'GI': 'gibraltar', 'GL': 'greenland', 'GM': 'gambia', 'GN': 'guinea', 'GP': 'guadeloupe',
      'GQ': 'equatorial-guinea', 'GR': 'greece', 'GS': 'south-georgia', 'GT': 'guatemala', 'GU': 'guam',
      'GW': 'guinea-bissau', 'GY': 'guyana', 'HK': 'hong-kong-sar-china', 'HM': 'heard-island',
      'HN': 'honduras', 'HR': 'croatia', 'HT': 'haiti', 'HU': 'hungary', 'ID': 'indonesia',
      'IE': 'ireland', 'IL': 'israel', 'IM': 'isle-of-man', 'IN': 'india', 'IO': 'british-indian-ocean-territory',
      'IQ': 'iraq', 'IR': 'iran', 'IS': 'iceland', 'IT': 'italy', 'JE': 'jersey', 'JM': 'jamaica',
      'JO': 'jordan', 'JP': 'japan', 'KE': 'kenya', 'KG': 'kyrgyzstan', 'KH': 'cambodia',
      'KI': 'kiribati', 'KM': 'comoros', 'KN': 'saint-kitts-and-nevis', 'KP': 'north-korea',
      'KR': 'south-korea', 'KW': 'kuwait', 'KY': 'cayman-islands', 'KZ': 'kazakhstan', 'LA': 'laos',
      'LB': 'lebanon', 'LC': 'saint-lucia', 'LI': 'liechtenstein', 'LK': 'sri-lanka', 'LR': 'liberia',
      'LS': 'lesotho', 'LT': 'lithuania', 'LU': 'luxembourg', 'LV': 'latvia', 'LY': 'libya',
      'MA': 'morocco', 'MC': 'monaco', 'MD': 'moldova', 'ME': 'montenegro', 'MF': 'saint-martin',
      'MG': 'madagascar', 'MH': 'marshall-islands', 'MK': 'north-macedonia', 'ML': 'mali', 'MM': 'myanmar',
      'MN': 'mongolia', 'MO': 'macau-sar-china', 'MP': 'northern-mariana-islands', 'MQ': 'martinique',
      'MR': 'mauritania', 'MS': 'montserrat', 'MT': 'malta', 'MU': 'mauritius', 'MV': 'maldives',
      'MW': 'malawi', 'MX': 'mexico', 'MY': 'malaysia', 'MZ': 'mozambique', 'NA': 'namibia',
      'NC': 'new-caledonia', 'NE': 'niger', 'NF': 'norfolk-island', 'NG': 'nigeria', 'NI': 'nicaragua',
      'NL': 'netherlands', 'NO': 'norway', 'NP': 'nepal', 'NR': 'nauru', 'NU': 'niue',
      'NZ': 'new-zealand', 'OM': 'oman', 'PA': 'panama', 'PE': 'peru', 'PF': 'french-polynesia',
      'PG': 'papua-new-guinea', 'PH': 'philippines', 'PK': 'pakistan', 'PL': 'poland', 'PM': 'saint-pierre-and-miquelon',
      'PN': 'pitcairn', 'PR': 'puerto-rico', 'PS': 'palestine', 'PT': 'portugal', 'PW': 'palau',
      'PY': 'paraguay', 'QA': 'qatar', 'RE': 'reunion', 'RO': 'romania', 'RS': 'serbia',
      'RU': 'russia', 'RW': 'rwanda', 'SA': 'saudi-arabia', 'SB': 'solomon-islands', 'SC': 'seychelles',
      'SD': 'sudan', 'SE': 'sweden', 'SG': 'singapore', 'SH': 'saint-helena', 'SI': 'slovenia',
      'SJ': 'svalbard-and-jan-mayen', 'SK': 'slovakia', 'SL': 'sierra-leone', 'SM': 'san-marino',
      'SN': 'senegal', 'SO': 'somalia', 'SR': 'suriname', 'SS': 'south-sudan', 'ST': 'sao-tome-and-principe',
      'SV': 'el-salvador', 'SX': 'sint-maarten', 'SY': 'syria', 'SZ': 'eswatini', 'TC': 'turks-and-caicos',
      'TD': 'chad', 'TF': 'french-southern-territories', 'TG': 'togo', 'TH': 'thailand', 'TJ': 'tajikistan',
      'TK': 'tokelau', 'TL': 'timor-leste', 'TM': 'turkmenistan', 'TN': 'tunisia', 'TO': 'tonga',
      'TR': 'turkey', 'TT': 'trinidad-and-tobago', 'TV': 'tuvalu', 'TW': 'taiwan', 'TZ': 'tanzania',
      'UA': 'ukraine', 'UG': 'uganda', 'UM': 'us-outlying-islands', 'US': 'united-states', 'UY': 'uruguay',
      'UZ': 'uzbekistan', 'VA': 'vatican-city', 'VC': 'saint-vincent-and-the-grenadines', 'VE': 'venezuela',
      'VG': 'british-virgin-islands', 'VI': 'us-virgin-islands', 'VN': 'vietnam', 'VU': 'vanuatu',
      'WF': 'wallis-and-futuna', 'WS': 'samoa', 'XK': 'kosovo', 'YE': 'yemen', 'YT': 'mayotte',
      'ZA': 'south-africa', 'ZM': 'zambia', 'ZW': 'zimbabwe'
    };
    
    // Check if this is a country code (2 uppercase letters, e.g., "US", "CN", "HK")
    if (countryTrimmed.length === 2 && /^[A-Z]{2}$/.test(countryTrimmed)) {
      const countryName = countryCodeToName[countryTrimmed];
      if (countryName) {
        return `emojione-v1:flag-for-${countryName}`;
      }
      // If code not found, return null to show text fallback
      return null;
    }
    
    // Fallback: if it's a country name, convert to flag format
    // This handles legacy data or manual entries
    let countryLower = countryTrimmed.toLowerCase();
    
    // Remove common prefixes that don't appear in flag names
    const prefixesToRemove = [
      'the ',
      'republic of ',
      'kingdom of ',
      'state of ',
      'island of ',
      'islands of ',
      'federation of ',
      'union of ',
      'commonwealth of ',
      'democratic republic of ',
      'democratic republic of the ',
      'people\'s republic of ',
      'republic of the ',
      'united states of ',
      'united kingdom of ',
    ];
    
    // Remove prefixes
    for (const prefix of prefixesToRemove) {
      if (countryLower.startsWith(prefix)) {
        countryLower = countryLower.substring(prefix.length);
        break; // Only remove one prefix
      }
    }
    
    // Special mappings for countries that need specific flag names
    const specialFlagMap = {
      'hong kong': 'hong-kong-sar-china',
      'hongkong': 'hong-kong-sar-china',
      'macau': 'macau-sar-china',
      'macao': 'macau-sar-china',
      'netherlands': 'netherlands',
      'usa': 'united-states',
      'us': 'united-states',
      'united states': 'united-states',
      'uk': 'united-kingdom',
      'united kingdom': 'united-kingdom',
      'uae': 'united-arab-emirates',
      'united arab emirates': 'united-arab-emirates',
      'korea': 'south-korea',
      'south korea': 'south-korea',
      'north korea': 'north-korea',
      'czech republic': 'czech-republic',
      'russian federation': 'russia',
      'myanmar': 'myanmar',
      'burma': 'myanmar',
      'bosnia': 'bosnia-and-herzegovina',
      'bosnia and herzegovina': 'bosnia-and-herzegovina',
      'guinea bissau': 'guinea-bissau',
    };
    
    // Check if there's a special mapping (after prefix removal)
    if (specialFlagMap[countryLower]) {
      return `emojione-v1:flag-for-${specialFlagMap[countryLower]}`;
    }
    
    // Convert country name to flag icon path:
    // 1. Convert to lowercase (already done)
    // 2. Replace spaces with hyphens
    // 3. Remove commas
    // 4. Keep sar, china, territories, etc. as they are (no special handling needed)
    let flagName = countryLower
      .replace(/\s+/g, '-')  // Replace spaces with hyphens
      .replace(/,/g, '')      // Remove commas
      .replace(/--+/g, '-')  // Replace multiple hyphens with single hyphen
      .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
    
    return `emojione-v1:flag-for-${flagName}`;
  };

  const loadOSIcons = async () => {
    const iconElements = document.querySelectorAll('.os-icon');
    for (const el of iconElements) {
      const iconName = el.dataset.icon;
      if (!iconName) continue;
      try {
        // OS icon: use a reasonable default size, CSS classes will control the actual display size
        const response = await fetch(`https://api.iconify.design/${iconName}.svg?height=26`);
        if (response.ok) {
          const svg = await response.text();
          el.innerHTML = svg;
          const svgEl = el.querySelector('svg');
          if (svgEl) {
            svgEl.setAttribute('class', 'block leading-none w-5 h-5 sm:w-[26px] sm:h-[26px]');
            svgEl.style.margin = '0';
            svgEl.style.padding = '0';
            svgEl.style.display = 'block';
            svgEl.style.verticalAlign = 'middle'; // Center align for consistent row height
            svgEl.style.lineHeight = '1'; // Remove line height spacing
            svgEl.style.width = '100%';
            svgEl.style.height = '100%';
            svgEl.style.maxWidth = '100%';
            svgEl.style.maxHeight = '100%';
          }
        }
      } catch (e) {
        // Icon load failed silently
      }
    }
  };

  const loadFlagIcons = async () => {
    const flagElements = document.querySelectorAll('.flag-icon');
    for (const el of flagElements) {
      const iconName = el.dataset.icon;
      if (!iconName) continue;
      try {
        // Flag icon: use a reasonable default size, CSS classes will control the actual display size
        const response = await fetch(`https://api.iconify.design/${iconName}.svg?height=32`);
        if (response.ok) {
          const svg = await response.text();
          el.innerHTML = svg;
          const svgEl = el.querySelector('svg');
          if (svgEl) {
            svgEl.setAttribute('class', 'block leading-none w-6 h-6 sm:w-8 sm:h-8');
            svgEl.style.margin = '0';
            svgEl.style.padding = '0';
            svgEl.style.display = 'block';
            svgEl.style.verticalAlign = 'middle'; // Center align for consistent row height
            svgEl.style.lineHeight = '1'; // Remove line height spacing
            svgEl.style.width = '100%';
            svgEl.style.height = '100%';
            svgEl.style.maxWidth = '100%';
            svgEl.style.maxHeight = '100%';
          }
        }
      } catch (e) {
        // Flag icon load failed silently
      }
    }
  };

  // Detect CPU brand from CPU model string

  const root = document.getElementById('monitor-root');
  const apiBase = getApiBase(root);

  const body = document.getElementById('systems-body');
  const loadingIndicator = document.getElementById('loading-indicator');
  
  // SSE connection for real-time updates
  let eventSource = null;
  
  // Cache current data for comparison
  let currentData = new Map(); // key: system ID, value: system data

  // Sort state (temporary, not persisted)
  let currentSort = {
    field: null, // 'name', 'time', 'os', or null (no sort - default backend order)
    direction: 'asc' // 'asc', 'desc'
  };

  // Filter state
  let currentFilter = '';

  // Filter systems function - filters systems based on search query
  function filterSystems(systems) {
    if (!currentFilter || currentFilter.trim() === '') {
      return systems; // No filter
    }

    const filterLower = currentFilter.trim().toLowerCase();
    return systems.filter(system => {
      // Search in name
      const name = (system.name || '').toLowerCase();
      if (name.includes(filterLower)) return true;

      // Search in location
      const location = (system.location || '').toLowerCase();
      if (location.includes(filterLower)) return true;

      // Search in OS
      const os = (system.os || '').toLowerCase();
      if (os.includes(filterLower)) return true;

      // Search in CPU model
      const cpuModel = (system.cpu_model || '').toLowerCase();
      if (cpuModel.includes(filterLower)) return true;

      // Search in IP addresses
      const ipv4 = (system.ipv4 || '').toLowerCase();
      const ipv6 = (system.ipv6 || '').toLowerCase();
      if (ipv4.includes(filterLower) || ipv6.includes(filterLower)) return true;

      return false;
    });
  }

  // Sort systems function - sorts ALL systems regardless of alert/status
  function sortSystems(systems) {
    if (!currentSort.field) {
      return systems; // No sorting
    }

    const sorted = [...systems].sort((a, b) => {
      let aVal, bVal;
      let aIsEmpty = false;
      let bIsEmpty = false;

      switch (currentSort.field) {
        case 'name':
          aVal = (a.name || '').trim().toLowerCase();
          bVal = (b.name || '').trim().toLowerCase();
          aIsEmpty = !aVal;
          bIsEmpty = !bVal;
          break;
        case 'time':
          // Parse time string (format: "HH:MM:SS" or "X hours" or "X days")
          aVal = (a.time || '').trim();
          bVal = (b.time || '').trim();
          aIsEmpty = !aVal;
          bIsEmpty = !bVal;
          
          // If both are non-empty, try to parse for better sorting
          if (!aIsEmpty && !bIsEmpty) {
            // Try to extract numeric values for comparison
            const aNum = extractTimeValue(aVal);
            const bNum = extractTimeValue(bVal);
            if (aNum !== null && bNum !== null) {
              // Both have numeric values, compare numerically
              if (aNum < bNum) return currentSort.direction === 'asc' ? -1 : 1;
              if (aNum > bNum) return currentSort.direction === 'asc' ? 1 : -1;
              return 0;
            }
          }
          break;
        case 'os':
          aVal = (a.os || '').trim().toLowerCase();
          bVal = (b.os || '').trim().toLowerCase();
          aIsEmpty = !aVal;
          bIsEmpty = !bVal;
          break;
        default:
          return 0;
      }

      // Handle empty values: empty values go to the end (or beginning for desc)
      if (aIsEmpty && bIsEmpty) return 0;
      if (aIsEmpty) return currentSort.direction === 'asc' ? 1 : -1; // Empty goes to end for asc, beginning for desc
      if (bIsEmpty) return currentSort.direction === 'asc' ? -1 : 1; // Empty goes to end for asc, beginning for desc

      // String comparison for non-empty values
      if (aVal < bVal) return currentSort.direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return currentSort.direction === 'asc' ? 1 : -1;
      return 0;
    });

    return sorted;
  }

  // Helper function to extract numeric value from time string
  function extractTimeValue(timeStr) {
    if (!timeStr) return null;
    
    // Try to match patterns like "5h", "2d", "5 hours", "2 days", "12:34:56", etc.
    // First try compact format (no space): "0h", "11d", "120d"
    const compactHoursMatch = timeStr.match(/(\d+)h/i);
    if (compactHoursMatch) {
      return parseInt(compactHoursMatch[1], 10); // Return hours as number
    }
    
    const compactDaysMatch = timeStr.match(/(\d+)d/i);
    if (compactDaysMatch) {
      return parseInt(compactDaysMatch[1], 10) * 24; // Convert days to hours for comparison
    }
    
    // Try to match patterns with space: "5 hours", "2 days"
    const hoursMatch = timeStr.match(/(\d+)\s*hours?/i);
    if (hoursMatch) {
      return parseInt(hoursMatch[1], 10); // Return hours as number
    }
    
    const daysMatch = timeStr.match(/(\d+)\s*days?/i);
    if (daysMatch) {
      return parseInt(daysMatch[1], 10) * 24; // Convert days to hours for comparison
    }
    
    // Try to parse as HH:MM:SS
    const timeMatch = timeStr.match(/(\d+):(\d+):(\d+)/);
    if (timeMatch) {
      const hours = parseInt(timeMatch[1], 10);
      const minutes = parseInt(timeMatch[2], 10);
      const seconds = parseInt(timeMatch[3], 10);
      return hours + minutes / 60 + seconds / 3600; // Convert to hours
    }
    
    return null; // Could not parse
  }

  // Update sort UI
  function updateSortUI() {
    // Update sort indicators
    document.querySelectorAll('.sort-option').forEach(btn => {
      const indicator = btn.querySelector('.sort-indicator');
      if (btn.dataset.sort === currentSort.field) {
        btn.classList.add('bg-[#282828]', 'dark:bg-[#282828]', 'bg-[#f5f5f5]');
        if (indicator) {
          indicator.classList.remove('hidden');
          // Show direction arrow in indicator
          const isAsc = currentSort.direction === 'asc';
          indicator.innerHTML = isAsc 
            ? '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 15-6-6-6 6"/></svg>'
            : '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>';
        }
      } else {
        btn.classList.remove('bg-[#282828]', 'dark:bg-[#282828]', 'bg-[#f5f5f5]');
        if (indicator) {
          indicator.classList.add('hidden');
          // Reset to check icon
          indicator.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>';
        }
      }
    });
  }

  // Columns dropdown controls
  const columnsBtn = document.getElementById('columns-btn');
  const columnsDropdown = document.getElementById('columns-dropdown');
  const columnsContainer = document.getElementById('columns-dropdown-container');

  // Toggle dropdown
  columnsBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    columnsDropdown?.classList.toggle('hidden');
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (columnsContainer && !columnsContainer.contains(e.target)) {
      columnsDropdown?.classList.add('hidden');
    }
  });

  // Sort option buttons
  document.querySelectorAll('.sort-option').forEach(btn => {
    btn.addEventListener('click', () => {
      const sortField = btn.dataset.sort;
      if (sortField) {
        // If clicking the same field, toggle direction
        if (currentSort.field === sortField) {
          currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
          currentSort.field = sortField;
          currentSort.direction = 'asc'; // Reset to ascending for new field
        }
        updateSortUI();
        loadData(); // Reload with new sort
      }
    });
  });

  // Initialize sort UI (no sort by default - shows backend order)
  updateSortUI();

  const pct = (val) => Math.min(Math.max(val || 0, 0), 100);

  // Calculate and adjust server name column width based on longest name
  function adjustServerNameColumnWidth() {
    if (!body) return;
    
    const rows = body.querySelectorAll('.system-row');
    if (rows.length === 0) return;
    
    let maxWidth = 160; // Minimum width in pixels
    
    // Find the maximum width of server name cells by measuring actual cell width
    rows.forEach(systemRow => {
      const rowElement = systemRow.querySelector('[data-system-id]');
      if (!rowElement) return;
      
      const nameCell = rowElement.querySelector('div:first-child');
      if (nameCell) {
        // Measure the actual width of the entire cell (including all internal elements)
        // This gives us the most accurate measurement
        const cellWidth = nameCell.offsetWidth;
        if (cellWidth > 0) {
          maxWidth = Math.max(maxWidth, cellWidth);
        }
      }
    });
    
    // If we couldn't measure any cells (they might not be rendered yet), use a fallback
    if (maxWidth === 160) {
      // Try to measure text width as fallback
      rows.forEach(systemRow => {
        const rowElement = systemRow.querySelector('[data-system-id]');
        if (!rowElement) return;
        
        const nameCell = rowElement.querySelector('div:first-child');
        if (nameCell) {
          const spans = nameCell.querySelectorAll('span');
          for (let i = 0; i < spans.length; i++) {
            const span = spans[i];
            if (!span.classList.contains('rounded-full') && span.textContent && span.textContent.trim() !== '') {
              const tempSpan = document.createElement('span');
              const computedStyle = window.getComputedStyle(span);
              tempSpan.style.cssText = `
                position: absolute;
                visibility: hidden;
                white-space: nowrap;
                font-family: ${computedStyle.fontFamily};
                font-size: ${computedStyle.fontSize};
                font-weight: ${computedStyle.fontWeight};
                letter-spacing: ${computedStyle.letterSpacing};
              `;
              tempSpan.textContent = span.textContent.trim();
              document.body.appendChild(tempSpan);
              
              const textWidth = tempSpan.offsetWidth;
              // Add space for status dot, gaps, and copy button
              const estimatedCellWidth = textWidth + 40;
              maxWidth = Math.max(maxWidth, estimatedCellWidth);
              
              document.body.removeChild(tempSpan);
              break;
            }
          }
        }
      });
    }
    
    // Set the column width for all rows and header using inline style
    const columnWidth = `${Math.ceil(maxWidth)}px`;
    const gridTemplateColumns = `minmax(160px,${columnWidth}) minmax(85px,1fr) minmax(90px,1fr) minmax(130px,1.6fr) minmax(130px,1.6fr) minmax(130px,1.6fr) minmax(95px,1fr) minmax(90px,1fr)`;
    
    // Update all table rows
    rows.forEach(systemRow => {
      const rowElement = systemRow.querySelector('[data-system-id]');
      if (rowElement) {
        rowElement.style.gridTemplateColumns = gridTemplateColumns;
      }
    });
    
    // Update table header row to match - this ensures perfect alignment
    const headerRow = document.getElementById('system-table-header-row');
    if (headerRow) {
      headerRow.style.gridTemplateColumns = gridTemplateColumns;
    }
  }
  
  // Debounced version for performance
  let adjustColumnWidthTimeout = null;
  function adjustServerNameColumnWidthDebounced() {
    if (adjustColumnWidthTimeout) {
      clearTimeout(adjustColumnWidthTimeout);
    }
    adjustColumnWidthTimeout = setTimeout(() => {
      adjustServerNameColumnWidth();
      adjustColumnWidthTimeout = null;
    }, 100);
  }

  // Get color class based on value threshold
  const getProgressColor = (value, isOffline = false) => {
    if (isOffline) return 'bg-red-500';
    if (value >= 90) return 'bg-red-500';
    if (value >= 80) return 'bg-orange-500';
    if (value >= 70) return 'bg-amber-500';
    return 'bg-emerald-500';
  };

  const progress = (value, warn = false, isOffline = false) => `
    <div class="flex items-center gap-1 pr-2 sm:pr-3 min-w-0 w-full">
      <span class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5] w-8 sm:w-10 shrink-0">${value.toFixed(1)}%</span>
      <div class="relative h-2.5 sm:h-3 flex-1 min-w-[60px] max-w-[100px] sm:max-w-[120px] overflow-hidden rounded-full bg-[#111] dark:bg-[#111] bg-[#e5e5e5]">
        <div class="absolute inset-y-0 left-0 h-full rounded-full transition-all duration-500 ease-out ${getProgressColor(value, isOffline)}" style="width:${pct(value)}%"></div>
    </div>
    </div>
  `;

  // SECURITY: HTML escape function to prevent XSS attacks
  function escapeHtml(text) {
    if (text == null) return '';
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
  }

  // SECURITY: HTML attribute escape function
  function escapeHtmlAttr(text) {
    if (text == null) return '';
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
  }

  const renderRow = (item, showTCPing = true) => {
    // Determine if system is offline/paused (alert = true means offline/paused)
    const isOffline = item.alert || false;
    // SECURITY: Escape all user-controlled data
    const safeId = escapeHtmlAttr(item.id || '');
    const safeName = escapeHtml(item.name || 'unknown');
    const safeNameAttr = escapeHtmlAttr(item.name || 'unknown');
    return `
    <div class="system-row" data-system-id="${safeId}">
      <div class="group grid grid-cols-[minmax(160px,max-content)_minmax(85px,1fr)_minmax(90px,1fr)_minmax(130px,1.6fr)_minmax(130px,1.6fr)_minmax(130px,1.6fr)_minmax(95px,1fr)_minmax(90px,1fr)] items-center gap-1 px-3 sm:px-4 md:px-6 py-2 sm:py-3 hover:bg-[#222]/50 dark:hover:bg-[#222]/50 hover:bg-[#f5f5f5] cursor-pointer transition-colors" data-system-id="${safeId}">
        <div class="flex items-center gap-1.5 min-h-[20px]">
          <span class="h-1.5 w-1.5 sm:h-2 sm:w-2 rounded-full ${isOffline ? 'bg-red-400' : 'bg-emerald-400'} shrink-0"></span>
          <span class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5]">${safeName}</span>
          <button class="copy-btn text-[#737373] dark:text-[#737373] text-[#525252] hover:text-[#d4d4d4] dark:hover:text-[#d4d4d4] hover:text-[#151515] opacity-0 group-hover:opacity-100 transition-opacity shrink-0" data-system-name="${safeNameAttr}" title="Copy system name">
            <svg class="copy-icon w-2.5 h-2.5 sm:w-3 sm:h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
            <svg class="check-icon w-2.5 h-2.5 sm:w-3 sm:h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;"><path d="M20 6L9 17l-5-5"/></svg>
          </button>
    </div>
        <div class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5] h-5 flex items-center">${item.time || '-'}</div>
        <div class="h-5 flex items-center" title="${escapeHtmlAttr(item.location || '-')}">
          ${item.location ? (() => {
            const flagIcon = countryToFlag(item.location);
            if (flagIcon) {
              return `<span class="flag-icon block leading-none w-6 h-6 sm:w-8 sm:h-8" data-icon="${escapeHtmlAttr(flagIcon)}"></span>`;
            }
            // SECURITY: Escape location to prevent XSS
            const safeLocation = escapeHtml(item.location);
            return `<span class="text-[10px] sm:text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040]">${safeLocation}</span>`;
          })() : '<span class="text-[10px] sm:text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040]">-</span>'}
    </div>
        <div class="h-5 flex items-center pr-2 sm:pr-3 min-w-0 w-full">${progress(item.cpu || 0, false, isOffline)}</div>
        <div class="h-5 flex items-center pr-2 sm:pr-3 min-w-0 w-full">${progress(item.memory || 0, false, isOffline)}</div>
        <div class="h-5 flex items-center pr-2 sm:pr-3 min-w-0 w-full">${progress((item.disk || 0), (item.disk || 0) > 65, isOffline)}</div>
        <div class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5] h-5 flex items-center">${((item.net_in_mb_s || 0) + (item.net_out_mb_s || 0)).toFixed(2)} MB/s</div>
        <div class="h-5 flex items-center justify-center w-full" title="${escapeHtmlAttr(item.os || '-')}">
          ${item.os_icon ? `<span class="os-icon block leading-none w-5 h-5 sm:w-[26px] sm:h-[26px]" data-icon="${escapeHtmlAttr(item.os_icon)}"></span>` : `<span class="text-[10px] sm:text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040]">${escapeHtml(item.os || '-')}</span>`}
    </div>
    </div>
      <!-- Expandable details section -->
      <div class="system-details hidden border-t border-[#404040]/50 dark:border-[#404040]/50 border-[#a3a3a3]/50 bg-[#1a1a1a] dark:bg-[#1a1a1a] bg-[#fafafa] overflow-hidden" data-details-id="${safeId}" style="width: 100%;">
        <div class="details-content px-3 sm:px-4 md:px-6 py-2 sm:py-3">
          <div class="flex flex-col gap-1.5 sm:gap-2 items-start">
            <!-- Tags (first row) -->
            ${item.tags && Array.isArray(item.tags) && item.tags.length > 0 ? `
            <div class="flex flex-wrap items-center gap-1.5 sm:gap-2 w-full">
              ${item.tags.map(tag => {
                // SECURITY: Escape tag to prevent XSS
                const safeTag = escapeHtml(tag);
                return `
                <span class="inline-flex items-center rounded-md bg-[#262626] dark:bg-[#262626] bg-[#d4d4d4] px-2 py-0.5 text-[10px] sm:text-xs font-medium text-[#404040] dark:text-[#f5f5f5]">
                  ${safeTag}
                </span>
              `;
              }).join('')}
            </div>
            ` : ''}
            <!-- CPU Info -->
            <div class="flex flex-wrap items-baseline gap-1.5 sm:gap-2" style="min-height: 16px; line-height: 16px;">
              <div class="text-[10px] sm:text-xs font-medium text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040] shrink-0" data-translate-detail="cpuInformation">CPU:</div>
              <div class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5] leading-normal" data-detail="cpu_model">${escapeHtml(item.cpu_model || '-')}</div>
            </div>
            <!-- Memory Info -->
            <div class="flex flex-wrap items-baseline gap-1.5 sm:gap-2">
              <div class="text-[10px] sm:text-xs font-medium text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040] shrink-0" data-translate-detail="memoryInfo">Memory:</div>
              <div class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5] leading-normal" data-detail="memory_info">${escapeHtml(item.memory_info || '-')}</div>
            </div>
            <!-- Swap Info -->
            <div class="flex flex-wrap items-baseline gap-1.5 sm:gap-2">
              <div class="text-[10px] sm:text-xs font-medium text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040] shrink-0" data-translate-detail="swapPartition">Swap:</div>
              <div class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5] leading-normal" data-detail="swap_info">${escapeHtml(item.swap_info || '-')}</div>
            </div>
            <!-- Disk Info -->
            <div class="flex flex-wrap items-baseline gap-1.5 sm:gap-2">
              <div class="text-[10px] sm:text-xs font-medium text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040] shrink-0" data-translate-detail="diskInformation">Disk:</div>
              <div class="text-[10px] sm:text-xs font-medium text-[#262626] dark:text-[#f5f5f5] leading-normal" data-detail="disk_info">${escapeHtml(item.disk_info || '-')}</div>
            </div>
          </div>
        </div>
      ${showTCPing ? `<!-- TCPing Chart Section -->
      <div class="border-t border-[#404040]/50 dark:border-[#404040]/50 border-[#a3a3a3]/50 px-3 sm:px-4 md:px-6 py-2 sm:py-3" data-tcping-chart-container="${safeId}" style="width: 100%;">
        <div class="rounded-lg border border-[#404040]/50 dark:border-[#404040]/50 border-[#a3a3a3]/50 bg-[#151515] dark:bg-[#151515] bg-white p-2 sm:p-3">
          <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 sm:gap-0 mb-2">
            <div class="text-[10px] sm:text-xs font-medium text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040]" data-translate-detail="tcpingLatency">TCPing Latency (24h)</div>
            <!-- Statistics display -->
            <div class="flex gap-3 sm:gap-4 text-[10px] sm:text-xs" data-tcping-stats="${safeId}">
              <div class="flex items-center gap-1">
                <span class="text-[#a3a3a3] dark:text-[#a3a3a3] text-[#525252]" data-translate-detail="avgLatency">Avg:</span>
                <span class="font-medium text-[#262626] dark:text-[#f5f5f5]" data-tcping-avg="${safeId}">-</span>
          </div>
              <div class="flex items-center gap-1">
                <span class="text-[#a3a3a3] dark:text-[#a3a3a3] text-[#525252]" data-translate-detail="packetLoss">Loss:</span>
                <span class="font-medium text-[#262626] dark:text-[#f5f5f5]" data-tcping-loss="${safeId}">-</span>
        </div>
        </div>
        </div>
          <!-- Tabs for different targets -->
          <div class="flex gap-1 mb-3 flex-wrap" data-tcping-tabs="${safeId}"></div>
          <!-- Chart canvas -->
          <div class="relative" style="height: 200px; width: 100%; min-height: 200px;">
            <!-- Loading state -->
            <div class="absolute inset-0 flex items-center justify-center bg-[#151515] dark:bg-[#151515] bg-white rounded" data-tcping-loading="${item.id}" style="height: 200px; min-height: 200px;">
              <div class="flex flex-col items-center gap-2">
                <div class="w-6 h-6 border-2 border-[#404040] dark:border-[#404040] border-[#a3a3a3] border-t-transparent dark:border-t-transparent rounded-full animate-spin"></div>
                <span class="text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#525252]" data-translate-detail="loading">Loading...</span>
        </div>
      </div>
            <!-- No data state -->
            <div class="absolute inset-0 flex items-center justify-center bg-[#151515] dark:bg-[#151515] bg-white rounded hidden" data-tcping-no-data="${safeId}" style="height: 200px; min-height: 200px;">
              <div class="flex flex-col items-center gap-2">
                <svg class="w-8 h-8 text-[#404040] dark:text-[#404040]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                </svg>
                <span class="text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#525252]" data-translate-detail="noData">No data</span>
    </div>
  </div>
            <canvas data-tcping-chart="${safeId}" style="width: 100%; height: 200px; min-height: 200px;" class="opacity-0 transition-opacity duration-300" data-tcping-canvas="${safeId}"></canvas>
</div>
      </div>` : ''}
    </div>
  </div>
</div>
  `;
  };

  const translations = {
    'noSystemsFound': { en: 'No services found', zh: '未找到服务' },
    'systemsWillAppear': { en: 'Services will appear here once agents start reporting', zh: '代理开始报告后，服务将显示在这里' },
    'cpuInformation': { en: 'CPU:', zh: 'CPU:' },
    'memoryInfo': { en: 'Memory:', zh: '内存:' },
    'swapPartition': { en: 'Swap:', zh: '交换:' },
    'diskInformation': { en: 'Disk:', zh: '磁盘:' },
    'tcpingLatency': { en: 'TCPing Latency (24h)', zh: 'TCPing 延迟 (24小时)' },
    'avgLatency': { en: 'Avg:', zh: '平均:' },
    'packetLoss': { en: 'Loss:', zh: '丢包:' },
    'loading': { en: 'Loading...', zh: '加载中...' },
    'noData': { en: 'No data', zh: '暂无数据' },
  };

  function getCurrentLanguage() {
    const stored = localStorage.getItem('preferred-language');
    if (stored === 'zh' || stored === 'en') {
      return stored;
    }
    // Default to English, not system language
    return 'en';
  }

  function updateTranslations() {
    const lang = getCurrentLanguage();
    
    // Update empty state - fix null check
    if (body) {
      const emptyState = body.querySelector('.text-sm.font-medium');
      if (emptyState && (emptyState.textContent === translations.noSystemsFound.en || emptyState.textContent === translations.noSystemsFound.zh)) {
        const emptyContainer = body.querySelector('.flex.flex-col.items-center');
        if (emptyContainer) {
          const noSystems = emptyContainer.querySelector('.text-sm.font-medium');
          const willAppear = emptyContainer.querySelector('.text-xs');
          if (noSystems) noSystems.textContent = translations.noSystemsFound[lang];
          if (willAppear) willAppear.textContent = translations.systemsWillAppear[lang];
        }
      }
    }
    
    // Update expandable details - search in entire document to include hidden elements
    document.querySelectorAll('[data-translate-detail]').forEach(el => {
      const key = el.getAttribute('data-translate-detail');
      if (key && translations[key]) {
        const translatedText = translations[key][lang];
        if (translatedText) {
          el.textContent = translatedText;
        }
      }
    });
  }

  // Listen for language changes
  window.addEventListener('languagechange', updateTranslations);
  window.addEventListener('translate', updateTranslations);
  
  // Update chart tooltip styles when theme changes
  window.addEventListener('themechange', (e) => {
    const theme = e.detail?.theme || (document.documentElement.classList.contains('dark') ? 'dark' : 'light');
    updateChartTooltipStyles(theme);
  });
  
  // Function to update tooltip styles for all charts
  function updateChartTooltipStyles(theme) {
    const isDarkMode = theme === 'dark';
    const tooltipBg = isDarkMode ? 'rgba(21, 21, 21, 0.95)' : 'rgba(250, 250, 250, 0.95)';
    const tooltipTextColor = isDarkMode ? '#f5f5f5' : '#262626';
    const tooltipBorderColor = isDarkMode ? '#404040' : '#a3a3a3';
    
    // Update all existing charts
    tcpingCharts.forEach((chartData, key) => {
      const chart = chartData.chart;
      if (chart && chart.options && chart.options.plugins && chart.options.plugins.tooltip) {
        // Safety check: ensure chart and canvas are still valid
        if (!chart.canvas || !chart.canvas.parentElement) {
          return;
        }
        
        chart.options.plugins.tooltip.backgroundColor = tooltipBg;
        chart.options.plugins.tooltip.titleColor = tooltipTextColor;
        chart.options.plugins.tooltip.bodyColor = tooltipTextColor;
        chart.options.plugins.tooltip.borderColor = tooltipBorderColor;
        
        try {
          chart.update('none'); // Update without animation
        } catch (err) {
          // Chart update failed silently
        }
      }
    });
  }

  const showEmpty = () => {
    if (loadingIndicator) loadingIndicator.style.display = 'none';
    if (body) {
      const lang = getCurrentLanguage();
      body.innerHTML = `
        <div class="flex flex-col items-center justify-center py-12 text-center">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" class="text-[#404040] dark:text-[#404040] text-[#d4d4d4] mb-3">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
            <line x1="8" y1="21" x2="16" y2="21"/>
            <line x1="12" y1="17" x2="12" y2="21"/>
          </svg>
          <p class="text-sm font-medium text-[#737373] dark:text-[#737373] text-[#404040]">${translations.noSystemsFound[lang]}</p>
          <p class="text-xs text-[#404040] dark:text-[#525252] text-[#737373] mt-1">${translations.systemsWillAppear[lang]}</p>
    </div>
  `;
    }
  };

  // Normalize data for comparison (ensure consistent types)
  function normalizeItem(item) {
    return {
      id: String(item.id || ''),
      name: String(item.name || ''),
      time: String(item.time || ''),
      location: String(item.location || ''),
      cpu: Number(item.cpu || 0),
      cpu_model: String(item.cpu_model || ''),
      memory: Number(item.memory || 0),
      memory_info: String(item.memory_info || ''),
      swap_info: String(item.swap_info || ''),
      disk: Number(item.disk || 0),
      disk_info: String(item.disk_info || ''),
      net_in_mb_s: Number(item.net_in_mb_s || 0),
      net_out_mb_s: Number(item.net_out_mb_s || 0),
      os: String(item.os || ''),
      os_icon: String(item.os_icon || ''),
      alert: Boolean(item.alert || false),
      order: Number(item.order || 0)
    };
  }
  
  // Check if two system objects have changed (excluding updated_at)
  function hasChanged(oldItem, newItem) {
    if (!oldItem) return true; // New item
    if (!newItem) return false; // Deleted item
    
    // Normalize both items for consistent comparison
    const old = normalizeItem(oldItem);
    const new_ = normalizeItem(newItem);
    
    // Helper to compare floats with small epsilon (0.1% change threshold)
    const floatEqual = (a, b) => Math.abs(a - b) < 0.1;
    
    // Compare relevant fields - only return true if there's a meaningful change
    return (
      old.name !== new_.name ||
      old.time !== new_.time ||
      old.location !== new_.location ||
      !floatEqual(old.cpu, new_.cpu) ||
      old.cpu_model !== new_.cpu_model ||
      !floatEqual(old.memory, new_.memory) ||
      old.memory_info !== new_.memory_info ||
      old.swap_info !== new_.swap_info ||
      !floatEqual(old.disk, new_.disk) ||
      old.disk_info !== new_.disk_info ||
      !floatEqual(old.net_in_mb_s, new_.net_in_mb_s) ||
      !floatEqual(old.net_out_mb_s, new_.net_out_mb_s) ||
      old.os !== new_.os ||
      old.os_icon !== new_.os_icon ||
      old.alert !== new_.alert ||
      old.order !== new_.order
    );
  }
  
  // Update a single row in the DOM - only update changed cells
  function updateRow(rowElement, item, previousItem) {
    if (!rowElement) return;
    
    // Get cached old item for comparison (normalized)
    // Use previousItem if provided, otherwise fall back to currentData
    const oldItemNormalized = previousItem ? normalizeItem(previousItem) : (currentData.get(item.id) || normalizeItem({}));
    
    // Normalize new item for comparison
    const newItemNormalized = normalizeItem(item);
    
    // Get all cells (children of the grid row)
    const cells = Array.from(rowElement.children);
    if (cells.length < 8) return; // Safety check
    
    // If no old data, update all fields (treat as new item)
    const shouldUpdateAll = !previousItem && !currentData.get(item.id);
    
    // Cell 0: System name (with status dot and copy button)
    const systemCell = cells[0];
    if (systemCell) {
      if (shouldUpdateAll || oldItemNormalized.alert !== newItemNormalized.alert) {
        // Use rounded-full to match the status dot (which has h-1.5 w-1.5 sm:h-2 sm:w-2)
        const statusDot = systemCell.querySelector('span.rounded-full.shrink-0');
        if (statusDot) {
          // Offline/paused state: red, Online state: green
          // Preserve responsive classes: h-1.5 w-1.5 sm:h-2 sm:w-2
          statusDot.className = `h-1.5 w-1.5 sm:h-2 sm:w-2 rounded-full ${item.alert ? 'bg-red-400' : 'bg-emerald-400'} shrink-0`;
        }
      }
      if (shouldUpdateAll || oldItemNormalized.name !== newItemNormalized.name) {
        // Use font-medium to match the name span (which has text-[10px] sm:text-xs)
        // Exclude the status dot by checking it doesn't have rounded-full class
        const allSpans = systemCell.querySelectorAll('span.font-medium');
        for (const span of allSpans) {
          // The name span doesn't have rounded-full class, status dot does
          if (!span.classList.contains('rounded-full')) {
            span.textContent = item.name || 'unknown';
            break; // Found the name span, no need to continue
          }
        }
        const copyBtn = systemCell.querySelector('.copy-btn');
        if (copyBtn) {
          copyBtn.dataset.systemName = item.name || 'unknown';
        }
        // Recalculate column width when name changes
        adjustServerNameColumnWidthDebounced();
      }
    }
    
    // Cell 1: Time - only update if changed
    if (shouldUpdateAll || oldItemNormalized.time !== newItemNormalized.time) {
      const timeCell = cells[1];
      if (timeCell) {
        timeCell.textContent = item.time || '-';
      }
    }
    
    // Cell 2: Location - only update if changed
    if (shouldUpdateAll || oldItemNormalized.location !== newItemNormalized.location) {
      const locationCell = cells[2];
      if (locationCell) {
        if (item.location) {
          const flagIcon = countryToFlag(item.location);
          if (flagIcon) {
            locationCell.innerHTML = `<span class="flag-icon block leading-none w-6 h-6 sm:w-8 sm:h-8" data-icon="${flagIcon}"></span>`;
            locationCell.title = item.location; // Set title for tooltip
            setTimeout(() => loadFlagIcons(), 0);
          } else {
            // SECURITY: Escape HTML to prevent XSS
            const escapedLocation = (item.location || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
            locationCell.innerHTML = `<span class="text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040]">${escapedLocation}</span>`;
            locationCell.title = item.location || '';
          }
        } else {
          locationCell.innerHTML = '<span class="text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040]">-</span>';
          locationCell.title = '-';
        }
      }
    }
    
    // Check if system is offline/paused
    const isOffline = newItemNormalized.alert || false;
    
    // Cell 3: CPU - only update if changed (with threshold)
    const cpuChanged = Math.abs(oldItemNormalized.cpu - newItemNormalized.cpu) >= 0.1;
    // Helper function for dynamic color updates (same logic as getProgressColor)
    const getDynamicProgressColor = (value, isOffline = false) => {
      if (isOffline) return 'bg-red-500';
      if (value >= 90) return 'bg-red-500';
      if (value >= 80) return 'bg-orange-500';
      if (value >= 70) return 'bg-amber-500';
      return 'bg-emerald-500';
    };
    
    const cpuStatusChanged = oldItemNormalized.alert !== newItemNormalized.alert;
    if (shouldUpdateAll || cpuChanged || cpuStatusChanged) {
      const cpuCell = cells[3];
      if (cpuCell) {
        // Update progress bar and text directly
        // Use more flexible selector to match span with font-medium class (which has text-[10px] sm:text-xs)
        const textSpan = cpuCell.querySelector('span.font-medium');
        const progressBar = cpuCell.querySelector('div.absolute');
        const value = newItemNormalized.cpu;
        if (textSpan) {
          textSpan.textContent = `${value.toFixed(1)}%`;
        }
        if (progressBar) {
          progressBar.style.width = `${pct(value)}%`;
          // Update color based on threshold
          progressBar.className = `absolute inset-y-0 left-0 h-full rounded-full transition-all duration-500 ease-out ${getDynamicProgressColor(value, isOffline)}`;
        }
      }
    }
    
    // Cell 4: Memory - only update if changed (with threshold)
    const memoryChanged = Math.abs(oldItemNormalized.memory - newItemNormalized.memory) >= 0.1;
    const memoryStatusChanged = oldItemNormalized.alert !== newItemNormalized.alert;
    if (shouldUpdateAll || memoryChanged || memoryStatusChanged) {
      const memoryCell = cells[4];
      if (memoryCell) {
        // Use more flexible selector to match span with font-medium class (which has text-[10px] sm:text-xs)
        const textSpan = memoryCell.querySelector('span.font-medium');
        const progressBar = memoryCell.querySelector('div.absolute');
        const value = newItemNormalized.memory;
        if (textSpan) {
          textSpan.textContent = `${value.toFixed(1)}%`;
        }
        if (progressBar) {
          progressBar.style.width = `${pct(value)}%`;
          // Update color based on threshold
          progressBar.className = `absolute inset-y-0 left-0 h-full rounded-full transition-all duration-500 ease-out ${getDynamicProgressColor(value, isOffline)}`;
        }
      }
    }
    
    // Cell 5: Disk - only update if changed (with threshold)
    const diskChanged = Math.abs(oldItemNormalized.disk - newItemNormalized.disk) >= 0.1;
    const diskStatusChanged = oldItemNormalized.alert !== newItemNormalized.alert;
    if (shouldUpdateAll || diskChanged || diskStatusChanged) {
      const diskCell = cells[5];
      if (diskCell) {
        // Use more flexible selector to match span with font-medium class (which has text-[10px] sm:text-xs)
        const textSpan = diskCell.querySelector('span.font-medium');
        const progressBar = diskCell.querySelector('div.absolute');
        const value = newItemNormalized.disk;
        if (textSpan) {
          textSpan.textContent = `${value.toFixed(1)}%`;
        }
        if (progressBar) {
          progressBar.style.width = `${pct(value)}%`;
          // Update color based on threshold
          progressBar.className = `absolute inset-y-0 left-0 h-full rounded-full transition-all duration-500 ease-out ${getDynamicProgressColor(value, isOffline)}`;
        }
      }
    }
    
    // Cell 6: Net - only update if changed (with threshold)
    const netInChanged = Math.abs(oldItemNormalized.net_in_mb_s - newItemNormalized.net_in_mb_s) >= 0.01;
    const netOutChanged = Math.abs(oldItemNormalized.net_out_mb_s - newItemNormalized.net_out_mb_s) >= 0.01;
    if (shouldUpdateAll || netInChanged || netOutChanged) {
      const netCell = cells[6];
      if (netCell) {
        netCell.textContent = `${(newItemNormalized.net_in_mb_s + newItemNormalized.net_out_mb_s).toFixed(2)} MB/s`;
      }
    }
    
    // Cell 7: OS - only update if changed
    if (oldItemNormalized.os !== newItemNormalized.os || oldItemNormalized.os_icon !== newItemNormalized.os_icon) {
      const osCell = cells[7];
      if (osCell) {
        if (item.os_icon) {
          osCell.innerHTML = `<span class="os-icon block leading-none w-5 h-5 sm:w-[26px] sm:h-[26px]" data-icon="${item.os_icon}"></span>`;
          setTimeout(() => loadOSIcons(), 0);
        } else {
          // SECURITY: Escape HTML to prevent XSS
          const escapedOS = (item.os || '-').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
          osCell.innerHTML = `<span class="text-xs text-[#a3a3a3] dark:text-[#a3a3a3] text-[#404040]">${escapedOS}</span>`;
        }
      }
    }
    
    // Update expandable details section if it exists and is visible
    // Always update the data, even if hidden, so it's ready when expanded
    const systemRow = rowElement.closest('.system-row');
    if (systemRow) {
      const detailsSection = systemRow.querySelector('.system-details');
      if (detailsSection) {
        // Update details content - check if values changed
        const cpuModelEl = detailsSection.querySelector('[data-detail="cpu_model"]');
        const memoryInfoEl = detailsSection.querySelector('[data-detail="memory_info"]');
        const swapInfoEl = detailsSection.querySelector('[data-detail="swap_info"]');
        const diskInfoEl = detailsSection.querySelector('[data-detail="disk_info"]');
        
        // Update CPU model if changed
        if (cpuModelEl) {
          const newCpuModel = String(item.cpu_model || '-');
          const oldCpuModel = cpuModelEl.textContent;
          if (oldCpuModel !== newCpuModel) {
            // Update text
            cpuModelEl.textContent = newCpuModel;
            
          }
        }
        
        // Update memory info if changed
        if (memoryInfoEl) {
          const newMemoryInfo = String(item.memory_info || '-');
          if (memoryInfoEl.textContent !== newMemoryInfo) {
            memoryInfoEl.textContent = newMemoryInfo;
          }
        }
        
        // Update swap info if changed
        if (swapInfoEl) {
          const newSwapInfo = String(item.swap_info || '-');
          if (swapInfoEl.textContent !== newSwapInfo) {
            swapInfoEl.textContent = newSwapInfo;
          }
        }
        
        // Update disk info if changed
        if (diskInfoEl) {
          const newDiskInfo = String(item.disk_info || '-');
          if (diskInfoEl.textContent !== newDiskInfo) {
            diskInfoEl.textContent = newDiskInfo;
          }
        }
      }
    }
  }
  
  // TCPing chart instances storage
  const tcpingCharts = new Map(); // key: systemId_target, value: { chart: Chart, target: string }
  const tcpingConfigs = new Map(); // key: systemId, value: TCPingConfig
  // Map to store current active target for each system
  const tcpingActiveTargets = new Map(); // systemId -> { target: address, targetName: name }
  // Map to track loading state for each system to allow cancellation
  const tcpingLoadingStates = new Map(); // systemId -> { loading: boolean, cancelled: boolean }
  
  // Global cache for TCPing config (preloaded on page load)
  let cachedTCPingConfig = null;
  let tcpingConfigLoading = null; // Promise to prevent duplicate fetches

  // Cleanup function to destroy tcping chart for a system
  function cleanupTCPingChart(systemId) {
    // Cancel any ongoing loading for this system
    const loadingState = tcpingLoadingStates.get(systemId);
    if (loadingState && loadingState.loading) {
      loadingState.cancelled = true;
    }
    
    // Find and destroy all charts for this system
    const chartsToDestroy = [];
    tcpingCharts.forEach((value, key) => {
      if (key.startsWith(`${systemId}_`)) {
        if (value.chart) {
          try {
            value.chart.destroy();
          } catch (err) {
            // Chart destroy failed silently
          }
        }
        chartsToDestroy.push(key);
      }
    });
    
    // Remove from map
    chartsToDestroy.forEach(key => tcpingCharts.delete(key));
    
    // Clear loading state
    tcpingLoadingStates.delete(systemId);
    
    // Reset canvas to ensure clean state for next initialization
    const container = document.querySelector(`[data-tcping-chart-container="${systemId}"]`);
    if (container) {
      const canvas = container.querySelector(`[data-tcping-chart="${systemId}"]`);
      if (canvas) {
        // Clear the canvas context
        const ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        // Reset canvas dimensions to ensure proper reinitialization
        // This will be recalculated when the chart is reopened
        canvas.width = 0;
        canvas.height = 0;
      }
    }
  }

  // Load tcping config (with caching)
  async function loadTCPingConfig(forceRefresh = false) {
    // Return cached config if available and not forcing refresh
    if (cachedTCPingConfig && !forceRefresh) {
      return cachedTCPingConfig;
    }
    
    // If already loading, wait for the existing promise
    if (tcpingConfigLoading && !forceRefresh) {
      return tcpingConfigLoading;
    }
    
    // Start loading
    tcpingConfigLoading = (async () => {
      try {
        const { url, headers } = buildAuthOptions(`${apiBase}/api/tcping/config`);
        const res = await fetch(url, { headers });
        if (res.ok) {
          const config = await res.json();
          cachedTCPingConfig = config;
          return config;
        }
      } catch (err) {
        // Config load failed silently
      }
      return null;
    })();
    
    const result = await tcpingConfigLoading;
    tcpingConfigLoading = null;
    return result;
  }
  
  // Preload TCPing config on page load
  function preloadTCPingConfig() {
    loadTCPingConfig().then(config => {
      if (config && config.targets && config.targets.length > 0) {
        // Also preload Chart.js if TCPing is configured
        preloadChartJS();
      }
    });
  }
  
  // Preload Chart.js library for faster chart rendering
  function preloadChartJS() {
    // Skip if already loaded or loading
    if (window.Chart || document.querySelector('script[data-chartjs]')) {
      return;
    }
    
    // Load Chart.js with fallback for Chinese networks
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
    script.onerror = function() {
      // Fallback to unpkg CDN if jsdelivr fails (better for Chinese networks)
      const fallbackScript = document.createElement('script');
      fallbackScript.src = 'https://unpkg.com/chart.js@4.4.0/dist/chart.umd.min.js';
      fallbackScript.async = true;
      fallbackScript.setAttribute('data-chartjs', 'true');
      document.head.appendChild(fallbackScript);
    };
    script.async = true;
    script.setAttribute('data-chartjs', 'true');
    script.onload = () => {
      // Also preload date adapter
      if (!document.querySelector('script[data-chartjs-adapter]')) {
        const adapterScript = document.createElement('script');
        adapterScript.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
        adapterScript.async = true;
        adapterScript.setAttribute('data-chartjs-adapter', 'true');
        adapterScript.onload = () => {
          window._chartjsAdapterLoaded = true;
        };
        document.head.appendChild(adapterScript);
      }
    };
    document.head.appendChild(script);
  }

  // Load tcping history data
  async function loadTCPingHistory(clientID, target) {
    try {
      let url = `${apiBase}/api/tcping/history?client_id=${encodeURIComponent(clientID)}${target ? `&target=${encodeURIComponent(target)}` : ''}`;
      const { url: authUrl, headers } = buildAuthOptions(url);
      const res = await fetch(authUrl, { headers });
      if (res.ok) {
        const data = await res.json();
        // Ensure we always return an array
        return Array.isArray(data) ? data : [];
      }
    } catch (err) {
      // History load failed silently
    }
    // Always return an empty array if there's an error or no data
    return [];
  }

  // Helper function to create tabs for TCPing targets
  function createTCPingTabs(systemId, config, tabsContainer) {
    // Clear existing tabs
    tabsContainer.innerHTML = '';
    
    // Check if there's a previously selected target for this system
    const activeTargetInfo = tcpingActiveTargets.get(systemId);
    const previouslySelectedTarget = activeTargetInfo ? activeTargetInfo.target : null;
    
    // Create tabs for each target
    config.targets.forEach((target, index) => {
      const tab = document.createElement('button');
      
      // Check if this tab should be active (restore previous selection)
      const isActive = previouslySelectedTarget === target.address;
      
      // Set initial state based on previous selection
      if (isActive) {
        tab.className = 'px-3 py-1 text-xs font-medium rounded transition-colors bg-[#404040]/50 dark:bg-[#404040]/50 text-[#f5f5f5] dark:text-[#f5f5f5] text-[#151515]';
      } else {
        tab.className = 'px-3 py-1 text-xs font-medium rounded transition-colors bg-transparent text-[#a3a3a3] dark:text-[#a3a3a3] text-[#525252] hover:bg-[#404040]/30 dark:hover:bg-[#404040]/30';
      }
      
      tab.textContent = target.name || target.address;
      tab.dataset.target = target.address;
      tab.dataset.targetName = target.name || target.address;

      tab.addEventListener('click', () => {
        // Check if this tab is already active
        const currentActiveTargetInfo = tcpingActiveTargets.get(systemId);
        const isCurrentlyActive = currentActiveTargetInfo && currentActiveTargetInfo.target === target.address;
        
        if (isCurrentlyActive) {
          // Clicking the active tab: deselect it and show all targets
          tab.className = 'px-3 py-1 text-xs font-medium rounded transition-colors bg-transparent text-[#a3a3a3] dark:text-[#a3a3a3] text-[#525252] hover:bg-[#404040]/30 dark:hover:bg-[#404040]/30';
          
          // Clear active target to show all targets with distinct colors
          tcpingActiveTargets.delete(systemId);
          
          // Update chart colors to show all targets (don't reload data)
          updateTCPingChartColors(systemId, null);
        } else {
          // Clicking an inactive tab: select it
          // Update all tabs to inactive state
          tabsContainer.querySelectorAll('button').forEach(btn => {
            btn.className = 'px-3 py-1 text-xs font-medium rounded transition-colors bg-transparent text-[#a3a3a3] dark:text-[#a3a3a3] text-[#525252] hover:bg-[#404040]/30 dark:hover:bg-[#404040]/30';
          });
          // Set clicked tab as active
          tab.className = 'px-3 py-1 text-xs font-medium rounded transition-colors bg-[#404040]/50 dark:bg-[#404040]/50 text-[#f5f5f5] dark:text-[#f5f5f5] text-[#151515]';
        
        // Update current active target for this system
        tcpingActiveTargets.set(systemId, {
          target: target.address,
          targetName: target.name || target.address
        });
        
          // Update chart colors based on selected target (don't reload data)
          updateTCPingChartColors(systemId, target.address);
        }
      });

      tabsContainer.appendChild(tab);
    });
    
    // Return the previously selected target (if any) to maintain state
    return previouslySelectedTarget;
  }

  // Initialize TCPing tabs immediately when details section expands
  async function initializeTCPingTabs(systemId) {
    const container = document.querySelector(`[data-tcping-chart-container="${systemId}"]`);
    if (!container) {
      return;
    }

    const tabsContainer = container.querySelector(`[data-tcping-tabs="${systemId}"]`);
    if (!tabsContainer) {
      return;
    }

    // Try to use cached config first for immediate tab display
    let config = cachedTCPingConfig;
    
    // If no cached config, fetch it
    if (!config) {
      config = await loadTCPingConfig();
    }
    
    if (!config || !config.targets || config.targets.length === 0) {
      container.style.display = 'none';
      return;
    }
    
    container.style.display = 'block';
    tcpingConfigs.set(systemId, config);

    // Create tabs immediately (no loading delay for tabs)
    // This will restore the previously selected target if any
    createTCPingTabs(systemId, config, tabsContainer);
  }

  // Initialize tcping chart for a system
  async function initializeTCPingChart(systemId) {
    const container = document.querySelector(`[data-tcping-chart-container="${systemId}"]`);
    if (!container) {
      return;
    }

    const canvas = container.querySelector(`[data-tcping-chart="${systemId}"]`);
    if (!canvas) {
      return;
    }

    // Set loading state
    tcpingLoadingStates.set(systemId, { loading: true, cancelled: false });

    // Show loading state for chart only (not tabs) - do this immediately without waiting
    const loadingElement = container.querySelector(`[data-tcping-loading="${systemId}"]`);
    if (loadingElement) {
      loadingElement.style.display = 'flex';
    }
    if (canvas) {
      canvas.classList.add('opacity-0');
    }

    // Get config (should already be loaded by initializeTCPingTabs)
    const config = tcpingConfigs.get(systemId);
    if (!config) {
      // Fallback: load config if tabs weren't initialized
      const loadedConfig = cachedTCPingConfig || await loadTCPingConfig();
      if (!loadedConfig || !loadedConfig.targets || loadedConfig.targets.length === 0) {
        tcpingLoadingStates.delete(systemId);
        return;
      }
      tcpingConfigs.set(systemId, loadedConfig);
    }

    // Check if cancelled before proceeding
    const loadingState = tcpingLoadingStates.get(systemId);
    if (!loadingState || loadingState.cancelled) {
      tcpingLoadingStates.delete(systemId);
      return;
    }

    // Get previously selected target from tabs
    const activeTargetInfo = tcpingActiveTargets.get(systemId);
    const restoredTarget = activeTargetInfo ? activeTargetInfo.target : null;

    // Initialize chart with all targets
    // If there's a restored target, the chart will show single line highlight
    // Otherwise, all lines will be colored
    await updateTCPingChart(systemId, null, null); // null means load all targets
    
    // Check if cancelled after chart update
    if (!tcpingLoadingStates.get(systemId) || tcpingLoadingStates.get(systemId).cancelled) {
      tcpingLoadingStates.delete(systemId);
      return;
    }
    
    // If there was a restored target, update chart colors to match the button state
    if (restoredTarget) {
      updateTCPingChartColors(systemId, restoredTarget);
    }
    
    // Clear loading state
    tcpingLoadingStates.delete(systemId);
  }

  // Update tcping chart with data for all targets
  async function updateTCPingChart(systemId, target, targetName, incremental = false) {
    const container = document.querySelector(`[data-tcping-chart-container="${systemId}"]`);
    if (!container) return;

    const canvas = container.querySelector(`[data-tcping-chart="${systemId}"]`);
    if (!canvas) return;
    
    // Check if loading was cancelled early
    const loadingState = tcpingLoadingStates.get(systemId);
    if (loadingState && loadingState.cancelled) {
      return;
    }
    
    // Get config for this system
    const config = tcpingConfigs.get(systemId);
    if (!config || !config.targets || config.targets.length === 0) {
      return;
    }
    
    // Show loading state if this is not an incremental update
    if (!incremental) {
      const loadingElement = container.querySelector(`[data-tcping-loading="${systemId}"]`);
      if (loadingElement) {
        loadingElement.style.display = 'flex';
      }
      canvas.classList.add('opacity-0');
    }

    // Get system data to find client ID
    const systemRow = document.querySelector(`[data-system-id="${systemId}"]`);
    if (!systemRow) return;

    // Get client ID from system data (assuming it's the same as system ID)
    const clientID = systemId;

    // Check if chart already exists for incremental update
    const chartKey = `${systemId}_all`;
    const existingChartData = tcpingCharts.get(chartKey);
    
    // Load history data for all targets
    const allHistoryData = await Promise.all(
      config.targets.map(target => loadTCPingHistory(clientID, target.address))
    );
    
    // Check if loading was cancelled after data fetch
    if (tcpingLoadingStates.get(systemId)?.cancelled) {
      return;
    }
    
    // Prepare chart data for all targets
    const PACKET_LOSS_THRESHOLD_MS = 1000;
    const now = new Date();
    const twentyFourHoursAgo = now.getTime() - (24 * 60 * 60 * 1000);
    
    // Get active target for color determination
    const activeTargetInfo = tcpingActiveTargets.get(systemId);
    const selectedTarget = activeTargetInfo ? activeTargetInfo.target : null; // null means no target selected (all colored)
    
    // Generate distinct colors for each target when no target is selected
    const defaultColors = [
      'rgb(34, 197, 94)',    // emerald-500 (green)
      'rgb(59, 130, 246)',  // blue-500
      'rgb(168, 85, 247)',  // purple-500
      'rgb(236, 72, 153)',  // pink-500
      'rgb(251, 146, 60)',  // orange-500
      'rgb(34, 211, 238)',  // cyan-500
      'rgb(132, 204, 22)',  // lime-500
      'rgb(245, 158, 11)',  // amber-500
    ];
    
    // Create datasets for each target
    const datasets = [];
    let hasAnyData = false;
    let minTime = null;
    let maxTime = null;
    
    config.targets.forEach((targetConfig, index) => {
      const historyData = allHistoryData[index];
      const safeHistoryData = Array.isArray(historyData) ? historyData : [];
      
      // Filter and sort by timestamp
      const sortedData = [...safeHistoryData]
        .filter(result => {
          const timestamp = new Date(result.timestamp).getTime();
          return timestamp >= twentyFourHoursAgo;
        })
        .sort((a, b) => {
          return new Date(a.timestamp) - new Date(b.timestamp);
        });
    
      if (sortedData.length > 0) {
        hasAnyData = true;
        // Track min and max time across all datasets for proper x-axis range
        const firstTime = new Date(sortedData[0].timestamp).getTime();
        const lastTime = new Date(sortedData[sortedData.length - 1].timestamp).getTime();
        if (minTime === null || firstTime < minTime) {
          minTime = firstTime;
        }
        if (maxTime === null || lastTime > maxTime) {
          maxTime = lastTime;
        }
      }
      
      const chartData = [];
      sortedData.forEach(result => {
        const timestamp = new Date(result.timestamp);
        let yValue = null;
        if (result.latency !== null && result.latency !== undefined) {
          if (result.latency > PACKET_LOSS_THRESHOLD_MS) {
            yValue = null; // Packet loss
          } else {
            yValue = result.latency;
          }
        }
        chartData.push({
          x: timestamp,
          y: yValue
        });
      });
    
      // Determine color based on whether a target is selected
      // If no target is selected (selectedTarget === null), all lines have distinct colors
      // If a target is selected, only that target is colored, others are gray
      const isSelected = selectedTarget !== null && targetConfig.address === selectedTarget;
      let borderColor, borderWidth;
      if (selectedTarget === null) {
        // No target selected: all lines have distinct colors
        borderColor = defaultColors[index % defaultColors.length];
        borderWidth = 2;
      } else {
        // Target selected: only selected target is colored, others are gray
        borderColor = isSelected ? 'rgb(34, 197, 94)' : 'rgba(163, 163, 163, 0.5)';
        borderWidth = isSelected ? 2 : 1.5;
      }
      
      datasets.push({
        label: `${targetConfig.name || targetConfig.address} (ms)`,
        data: chartData,
        borderColor: borderColor,
        backgroundColor: selectedTarget === null ? `${borderColor}20` : 'rgba(34, 197, 94, 0.1)', // Semi-transparent version of border color when all colored
        borderWidth: borderWidth,
        fill: false,
        tension: 0.1,
        spanGaps: true,
        pointRadius: 0,
        pointHoverRadius: 0,
        pointHitRadius: 5,
        showLine: true,
        targetAddress: targetConfig.address, // Store target address for color updates
        targetIndex: index // Store index for color lookup
      });
    });
    
    // Calculate statistics for all targets (will be updated when target is selected)
    calculateAndUpdateStats(systemId, selectedTarget);
    
    // Check if there's no data - show "No data" state instead of empty chart
    if (!hasAnyData) {
      // Hide loading state
      const loadingElement = container.querySelector(`[data-tcping-loading="${systemId}"]`);
      if (loadingElement) {
        loadingElement.style.display = 'none';
      }
      
      // Show "No data" state
      const noDataElement = container.querySelector(`[data-tcping-no-data="${systemId}"]`);
      if (noDataElement) {
        noDataElement.classList.remove('hidden');
        noDataElement.style.display = 'flex';
      }
      
      // Hide canvas
      if (canvas) {
        canvas.classList.add('opacity-0');
        canvas.style.display = 'none';
      }
      
      // Destroy any existing chart
      if (existingChartData && existingChartData.chart) {
        try {
          existingChartData.chart.destroy();
    } catch (err) {
          // Chart destroy failed silently
        }
        tcpingCharts.delete(chartKey);
      }
      
      // Update translations for no data state
      updateTranslations();
      return;
    }
    
    // Hide "No data" state if we have data
    const noDataElement = container.querySelector(`[data-tcping-no-data="${systemId}"]`);
    if (noDataElement) {
      noDataElement.classList.add('hidden');
      noDataElement.style.display = 'none';
    }
    
    // Show canvas if we have data
    if (canvas) {
      canvas.style.display = 'block';
    }
    
    // If chart exists and this is an incremental update, add only new data points
    if (incremental && existingChartData && existingChartData.chart) {
      const chart = existingChartData.chart;
      
      // Safety check: ensure chart and canvas are still valid
      if (!chart || !chart.canvas || !chart.canvas.parentElement) {
        return;
      }
      
      // Update each dataset with new data points
      let hasNewData = false;
      datasets.forEach((newDataset, index) => {
        if (index < chart.data.datasets.length) {
          const currentDataset = chart.data.datasets[index];
          const currentData = currentDataset.data || [];
          
          if (currentData.length > 0) {
            const lastCurrentDataPoint = currentData[currentData.length - 1];
            const lastCurrentTime = lastCurrentDataPoint ? lastCurrentDataPoint.x.getTime() : 0;
            
            // Find new data points
            const newDataPoints = newDataset.data.filter(point => point.x.getTime() > lastCurrentTime);
            
            if (newDataPoints.length > 0) {
              currentDataset.data.push(...newDataPoints);
              hasNewData = true;
            }
          } else {
            // No existing data, add all new data
            currentDataset.data = [...newDataset.data];
            hasNewData = true;
          }
          
          // Remove data older than 24 hours and ensure data is sorted by time
          currentDataset.data = currentDataset.data
            .filter(point => {
              return point.x.getTime() >= twentyFourHoursAgo;
            })
            .sort((a, b) => {
              return a.x.getTime() - b.x.getTime();
            });
        }
      });
        
      if (hasNewData) {
        try {
          if (chart && chart.canvas && chart.canvas.parentElement) {
            // Recalculate time range for all datasets after adding new data
            let updatedMinTime = null;
            let updatedMaxTime = null;
            
            chart.data.datasets.forEach(dataset => {
              if (dataset.data && dataset.data.length > 0) {
                // Data is now sorted, so first and last are min and max
                const firstTime = dataset.data[0].x.getTime();
                const lastTime = dataset.data[dataset.data.length - 1].x.getTime();
                if (updatedMinTime === null || firstTime < updatedMinTime) {
                  updatedMinTime = firstTime;
                }
                if (updatedMaxTime === null || lastTime > updatedMaxTime) {
                  updatedMaxTime = lastTime;
                }
              }
            });
            
            // Update x-axis range if we have valid time range
            if (updatedMinTime !== null && updatedMaxTime !== null && chart.options.scales && chart.options.scales.x) {
              chart.options.scales.x.min = updatedMinTime;
              chart.options.scales.x.max = updatedMaxTime;
            }
            
            chart.update('none');
            calculateAndUpdateStats(systemId, selectedTarget);
          }
        } catch (err) {
          // Chart update failed silently
        }
        }
        return;
    }
    
    // If incremental is true, we should have returned above
    if (incremental) {
      return;
    }
    
    // If no existing chart or full reload needed, destroy all charts for this system
    const chartsToDestroy = [];
    tcpingCharts.forEach((value, key) => {
      if (key.startsWith(`${systemId}_`)) {
        if (value.chart) {
          chartsToDestroy.push(value.chart);
        }
        tcpingCharts.delete(key);
      }
    });
    
    // Destroy all charts
    chartsToDestroy.forEach(chart => {
      try {
        chart.destroy();
      } catch (err) {
        // Chart destroy failed silently
      }
    });

    // Load Chart.js from CDN if not already loaded
    if (!window.Chart) {
      return new Promise((resolve, reject) => {
        // Check if script is already being loaded
        if (document.querySelector('script[data-chartjs]')) {
          const checkInterval = setInterval(() => {
            if (window.Chart && window._chartjsAdapterLoaded) {
              clearInterval(checkInterval);
              updateTCPingChart(systemId, target, targetName).then(resolve).catch(reject);
            }
          }, 100);
          setTimeout(() => {
            clearInterval(checkInterval);
            if (!window.Chart || !window._chartjsAdapterLoaded) {
              reject(new Error('Chart.js loading timeout'));
            }
          }, 10000);
          return;
        }
        
        // Load Chart.js first with fallback for Chinese networks
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
        script.onerror = function() {
          // Fallback to unpkg CDN if jsdelivr fails
          const fallbackScript = document.createElement('script');
          fallbackScript.src = 'https://unpkg.com/chart.js@4.4.0/dist/chart.umd.min.js';
          fallbackScript.async = true;
          fallbackScript.setAttribute('data-chartjs', 'true');
          fallbackScript.onload = () => {
            // Continue with adapter loading
            const adapterScript = document.createElement('script');
            adapterScript.src = 'https://unpkg.com/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
            adapterScript.async = true;
            adapterScript.setAttribute('data-chartjs-adapter', 'true');
            adapterScript.onload = () => {
              window._chartjsAdapterLoaded = true;
              updateTCPingChart(systemId, target, targetName).then(resolve).catch(reject);
            };
            adapterScript.onerror = () => {
              reject(new Error('Failed to load Chart.js date adapter'));
            };
            document.head.appendChild(adapterScript);
          };
          document.head.appendChild(fallbackScript);
        };
        script.async = true;
        script.setAttribute('data-chartjs', 'true');
        script.onload = () => {
          // Then load the date adapter for time scale support with fallback
          const adapterScript = document.createElement('script');
          adapterScript.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
          adapterScript.onerror = function() {
            // Fallback to unpkg CDN
            const fallbackAdapter = document.createElement('script');
            fallbackAdapter.src = 'https://unpkg.com/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
            fallbackAdapter.async = true;
            fallbackAdapter.setAttribute('data-chartjs-adapter', 'true');
            fallbackAdapter.onload = () => {
              window._chartjsAdapterLoaded = true;
            };
            document.head.appendChild(fallbackAdapter);
          };
          adapterScript.async = true;
          adapterScript.setAttribute('data-chartjs-adapter', 'true');
          adapterScript.onload = () => {
            window._chartjsAdapterLoaded = true;
            updateTCPingChart(systemId, target, targetName).then(resolve).catch(reject);
          };
          adapterScript.onerror = () => {
            // Fallback to unpkg CDN
            const fallbackAdapter = document.createElement('script');
            fallbackAdapter.src = 'https://unpkg.com/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
            fallbackAdapter.async = true;
            fallbackAdapter.setAttribute('data-chartjs-adapter', 'true');
            fallbackAdapter.onload = () => {
              window._chartjsAdapterLoaded = true;
              updateTCPingChart(systemId, target, targetName).then(resolve).catch(reject);
            };
            fallbackAdapter.onerror = () => {
            reject(new Error('Failed to load Chart.js date adapter'));
            };
            document.head.appendChild(fallbackAdapter);
          };
          document.head.appendChild(adapterScript);
        };
        script.onerror = () => {
          reject(new Error('Failed to load Chart.js'));
        };
        document.head.appendChild(script);
      });
    }
    
    // Also check if adapter is loaded
    if (!window._chartjsAdapterLoaded) {
      return new Promise((resolve, reject) => {
        if (document.querySelector('script[data-chartjs-adapter]')) {
          const checkInterval = setInterval(() => {
            if (window._chartjsAdapterLoaded) {
              clearInterval(checkInterval);
              updateTCPingChart(systemId, target, targetName).then(resolve).catch(reject);
            }
          }, 100);
          setTimeout(() => {
            clearInterval(checkInterval);
            if (!window._chartjsAdapterLoaded) {
              reject(new Error('Chart.js adapter loading timeout'));
            }
          }, 10000);
          return;
        }
        
        const adapterScript = document.createElement('script');
        adapterScript.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
        adapterScript.async = true;
        adapterScript.setAttribute('data-chartjs-adapter', 'true');
        adapterScript.onload = () => {
          window._chartjsAdapterLoaded = true;
          updateTCPingChart(systemId, target, targetName).then(resolve).catch(reject);
        };
        adapterScript.onerror = () => {
          // Fallback to unpkg CDN
          const fallbackAdapter = document.createElement('script');
          fallbackAdapter.src = 'https://unpkg.com/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
          fallbackAdapter.async = true;
          fallbackAdapter.setAttribute('data-chartjs-adapter', 'true');
          fallbackAdapter.onload = () => {
            window._chartjsAdapterLoaded = true;
            updateTCPingChart(systemId, target, targetName).then(resolve).catch(reject);
          };
          fallbackAdapter.onerror = () => {
          reject(new Error('Failed to load Chart.js date adapter'));
          };
          document.head.appendChild(fallbackAdapter);
        };
        document.head.appendChild(adapterScript);
      });
    }
    
    const ChartClass = window.Chart;

    // Check if we have data
    // Still create an empty chart to show the structure if no data

    // Check if there's an existing chart on this canvas and destroy it
    // This is a safety check in case the chart wasn't properly tracked
    if (ChartClass.getChart) {
      const existingChart = ChartClass.getChart(canvas);
      if (existingChart) {
        try {
          existingChart.destroy();
        } catch (err) {
          // Chart destroy failed silently
        }
      }
    }

    // Ensure canvas has proper dimensions
    // Use fixed dimensions from CSS (200px height) instead of getBoundingClientRect()
    // to avoid issues when container is still animating
    // Note: tabs are in external container, so they don't affect chart container height
    const parent = canvas.parentElement;
    if (parent) {
      const rect = parent.getBoundingClientRect();
      // Use fixed 200px height from CSS, or getBoundingClientRect if available and stable
      const width = rect.width > 0 ? rect.width : parent.offsetWidth || 0;
      const height = 200; // Fixed height from CSS style="height: 200px"
      
      if (width > 0 && height > 0) {
        // Get device pixel ratio for high-DPI displays (Retina, etc.)
        const dpr = window.devicePixelRatio || 1;
        
        // Set the canvas internal size (backing store size) to match device pixel ratio
        // This prevents blurriness on high-DPI displays
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        
        // Set the canvas CSS size to match the container
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        
        // Scale the context to match device pixel ratio
        // Chart.js will handle this automatically, but we need to set the dimensions
      }
    }

    // Create new chart
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      return;
    }
    
    // Detect current theme for tooltip styling
    const isDarkMode = document.documentElement.classList.contains('dark');
    const tooltipBg = isDarkMode ? 'rgba(21, 21, 21, 0.95)' : 'rgba(250, 250, 250, 0.95)';
    const tooltipTextColor = isDarkMode ? '#f5f5f5' : '#262626';
    const tooltipBorderColor = isDarkMode ? '#404040' : '#a3a3a3';
    
    // Register crosshair plugin if not already registered
    // Use a global variable to track if plugin is registered
    if (!window.crosshairPluginRegistered) {
      const crosshairPlugin = {
        id: 'crosshair',
        afterDraw: function(chart) {
          const tooltip = chart.tooltip;
          if (tooltip && tooltip.opacity > 0 && tooltip.dataPoints && tooltip.dataPoints.length > 0) {
            const ctx = chart.ctx;
            const dataPoint = tooltip.dataPoints[0];
            const x = dataPoint.element.x;
            const chartArea = chart.chartArea;
            
            // Detect current theme for crosshair color
            const currentIsDarkMode = document.documentElement.classList.contains('dark');
            const crosshairColor = currentIsDarkMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(38, 38, 38, 0.8)';
            
            // Save context state
            ctx.save();
            
            // Draw vertical crosshair line (theme-aware dashed line)
            ctx.strokeStyle = crosshairColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]); // Dashed line pattern
            ctx.beginPath();
            ctx.moveTo(x, chartArea.top);
            ctx.lineTo(x, chartArea.bottom);
            ctx.stroke();
            
            // Restore context state
            ctx.restore();
          }
        }
      };
      
      try {
        if (ChartClass.register) {
          ChartClass.register(crosshairPlugin);
          window.crosshairPluginRegistered = true;
        } else if (ChartClass.registry && ChartClass.registry.add) {
          ChartClass.registry.add(crosshairPlugin);
          window.crosshairPluginRegistered = true;
        }
      } catch (e) {
        // Plugin registration failed silently
      }
    }
    
    const chart = new ChartClass(ctx, {
      type: 'line',
      data: {
        datasets: datasets // All targets as separate datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        devicePixelRatio: window.devicePixelRatio || 1, // Explicitly set for high-DPI displays
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'x', // Use 'x' mode instead of 'index' to handle datasets with different start times
            intersect: false,
            backgroundColor: tooltipBg,
            titleColor: tooltipTextColor,
            bodyColor: tooltipTextColor,
            borderColor: tooltipBorderColor,
            borderWidth: 1,
            padding: 12,
            titleFont: {
              size: 12,
              weight: '600'
            },
            bodyFont: {
              size: 11
            },
            displayColors: false,
            filter: function(tooltipItem) {
              // Get active target for this system
              const systemId = canvas.dataset.tcpingChart;
              const activeTargetInfo = tcpingActiveTargets.get(systemId);
              const selectedTarget = activeTargetInfo ? activeTargetInfo.target : null;
              
              // If no target is selected, show all tooltips
              if (selectedTarget === null) {
                return true;
              }
              
              // If a target is selected, only show tooltip for that target
              const dataset = tooltipItem.dataset;
              return dataset.targetAddress === selectedTarget;
            },
            callbacks: {
              title: function(context) {
                if (context.length > 0 && context[0].label) {
                  return context[0].label;
                }
                return '';
              },
              label: function(context) {
                // Helper function to format label
                const formatLabel = (item) => {
                  const datasetLabel = item.dataset.label || '';
                  const value = item.parsed.y;
                  if (value === null || value === undefined) {
                    return `${datasetLabel}: Timeout/Failure`;
                  }
                  return `${datasetLabel}: ${value.toFixed(2)} ms`;
                };
                
                // Get all tooltip items for the current x position
                const allTooltipItems = context.chart.tooltip.dataPoints || [];
                
                // If no tooltip items or only one item, show it normally
                if (allTooltipItems.length <= 1) {
                  return formatLabel(context);
                }
                
                // Get the target address for the current item
                const currentTargetAddress = context.dataset.targetAddress;
                
                // Find the first item with the same target address
                const firstItemForTarget = allTooltipItems.find(item => 
                  item.dataset && item.dataset.targetAddress === currentTargetAddress
                );
                
                // If no matching target found, show current item (fallback)
                if (!firstItemForTarget) {
                  return formatLabel(context);
                }
                
                // Check if current item is the first one for this target
                // Compare by datasetIndex and dataIndex for reliable matching
                const isFirstItem = 
                  firstItemForTarget.datasetIndex === context.datasetIndex &&
                  firstItemForTarget.dataIndex === context.dataIndex;
                
                // Only show label if this is the first item for this target
                if (isFirstItem) {
                  return formatLabel(context);
                }
                
                // Return null to hide this label (duplicate for same target)
                return null;
              }
            }
          }
        },
        scales: {
          x: {
            type: 'time', // Use time scale for proper time-based X-axis
            // Set min/max based on all datasets to handle different start times correctly
            min: minTime !== null ? minTime : undefined,
            max: maxTime !== null ? maxTime : undefined,
            time: {
              displayFormats: {
                second: 'HH:mm:ss',
                minute: 'HH:mm',
                hour: 'HH:mm',
                day: 'MM/dd HH:mm'
              },
              tooltipFormat: 'yyyy-MM-dd HH:mm:ss' // Tooltip format with date and seconds
            },
            ticks: {
              color: '#a3a3a3',
              font: {
                size: 10
              },
              maxRotation: 0,
              minRotation: 0,
              maxTicksLimit: 6, // Show up to 6 ticks
              autoSkip: true,
              autoSkipPadding: 30
            },
            grid: {
              display: false, // Hide vertical grid lines (only show horizontal)
              drawOnChartArea: false
            },
            bounds: 'ticks' // Use 'ticks' instead of 'data' to ensure proper tooltip positioning
          },
          y: {
            beginAtZero: true,
            ticks: {
              color: '#a3a3a3',
              font: {
                size: 10
              },
              callback: function(value) {
                return value + ' ms';
              },
              // Make grid lines sparser by limiting number of ticks
              maxTicksLimit: 6 // Limit to 6 ticks to make grid lines sparser
            },
            grid: {
              color: 'rgba(64, 64, 64, 0.3)',
              display: true, // Show horizontal grid lines only
              // Make grid lines sparser by using stepSize
              drawOnChartArea: true
            },
            border: {
              display: false // Hide the Y-axis border line (left vertical line)
            }
          }
        },
        interaction: {
          mode: 'nearest',
          axis: 'x',
          intersect: false
        },
        onHover: function(event, activeElements) {
          // Keep default cursor style (don't change to crosshair)
          // The crosshair line will be drawn by the plugin
        }
      }
    });

    // Final check if loading was cancelled before storing chart
    if (tcpingLoadingStates.get(systemId)?.cancelled) {
      // Destroy the chart we just created since loading was cancelled
      try {
        chart.destroy();
      } catch (err) {
        // Ignore errors
      }
      return;
    }

    tcpingCharts.set(chartKey, { chart, target: 'all' });
    
    // Hide loading state and show chart (only if not incremental update)
    if (!incremental) {
      const loadingElement = container.querySelector(`[data-tcping-loading="${systemId}"]`);
      if (loadingElement) {
        loadingElement.style.display = 'none';
      }
      if (canvas) {
        canvas.classList.remove('opacity-0');
        
        // Hide "No data" state when chart is created
        const noDataElement = container.querySelector(`[data-tcping-no-data="${systemId}"]`);
        if (noDataElement) {
          noDataElement.classList.add('hidden');
          noDataElement.style.display = 'none';
        }
      }
    }
  }
  
  // Update TCPing statistics display
  function updateTCPingStats(systemId, avgLatency, packetLossRate) {
    const statsContainer = document.querySelector(`[data-tcping-stats="${systemId}"]`);
    if (!statsContainer) return;
    
    const avgElement = statsContainer.querySelector(`[data-tcping-avg="${systemId}"]`);
    const lossElement = statsContainer.querySelector(`[data-tcping-loss="${systemId}"]`);
    
    if (avgElement) {
      if (avgLatency > 0) {
        avgElement.textContent = `${avgLatency.toFixed(2)} ms`;
      } else {
        avgElement.textContent = '-';
      }
    }
    
    if (lossElement) {
      if (packetLossRate > 0) {
        lossElement.textContent = `${packetLossRate.toFixed(2)}%`;
      } else {
        lossElement.textContent = '0.00%';
      }
    }
  }
  
  // Update TCPing chart colors based on selected target
  function updateTCPingChartColors(systemId, selectedTarget) {
    const chartKey = `${systemId}_all`;
    const chartData = tcpingCharts.get(chartKey);
    if (!chartData || !chartData.chart) return;
    
    const chart = chartData.chart;
    const config = tcpingConfigs.get(systemId);
    if (!config || !config.targets) return;
    
    // Generate distinct colors for each target when no target is selected
    const defaultColors = [
      'rgb(34, 197, 94)',    // emerald-500 (green)
      'rgb(59, 130, 246)',  // blue-500
      'rgb(168, 85, 247)',  // purple-500
      'rgb(236, 72, 153)',  // pink-500
      'rgb(251, 146, 60)',  // orange-500
      'rgb(34, 211, 238)',  // cyan-500
      'rgb(132, 204, 22)',  // lime-500
      'rgb(245, 158, 11)',  // amber-500
    ];
    
    // Update colors for each dataset
    chart.data.datasets.forEach((dataset, index) => {
      const targetAddress = dataset.targetAddress;
      const targetIndex = dataset.targetIndex !== undefined ? dataset.targetIndex : index;
      
      if (selectedTarget === null) {
        // No target selected: all lines have distinct colors
        dataset.borderColor = defaultColors[targetIndex % defaultColors.length];
        dataset.borderWidth = 2;
        dataset.backgroundColor = `${defaultColors[targetIndex % defaultColors.length]}20`;
      } else if (targetAddress === selectedTarget) {
        // Selected target: emerald-500
        dataset.borderColor = 'rgb(34, 197, 94)';
        dataset.borderWidth = 2;
        dataset.backgroundColor = 'rgba(34, 197, 94, 0.1)';
      } else {
        // Other targets: gray color
        dataset.borderColor = 'rgba(163, 163, 163, 0.5)';
        dataset.borderWidth = 1.5;
        dataset.backgroundColor = 'rgba(163, 163, 163, 0.05)';
      }
    });
    
    chart.update('none');
    
    // Recalculate statistics based on selected target
    calculateAndUpdateStats(systemId, selectedTarget);
  }
  
  // Calculate and update statistics for selected target or all targets
  function calculateAndUpdateStats(systemId, selectedTarget) {
    const chartKey = `${systemId}_all`;
    const chartData = tcpingCharts.get(chartKey);
    if (!chartData || !chartData.chart) return;
    
    const chart = chartData.chart;
    const PACKET_LOSS_THRESHOLD_MS = 1000;
    
    let totalCount = 0;
    let successCount = 0;
    let totalLatency = 0;
    
    chart.data.datasets.forEach(dataset => {
      // If selectedTarget is specified, only count data from that target
      if (selectedTarget && dataset.targetAddress !== selectedTarget) {
        return;
      }
      
      dataset.data.forEach(point => {
        if (point && point.x && point.y !== null && point.y !== undefined) {
          totalCount++;
          if (point.y <= PACKET_LOSS_THRESHOLD_MS) {
            successCount++;
            totalLatency += point.y;
          }
        } else if (point && point.x) {
          // Null value (packet loss)
          totalCount++;
        }
      });
    });
    
    const avgLatency = successCount > 0 ? (totalLatency / successCount) : 0;
    const packetLossCount = totalCount - successCount;
    const packetLossRate = totalCount > 0 ? (packetLossCount / totalCount * 100) : 0;
    
    updateTCPingStats(systemId, avgLatency, packetLossRate);
  }
  
  // Setup row click handlers for expand/collapse
  const setupRowClickHandlers = (container) => {
    if (!container || container.dataset.rowClickSetup) return;
    container.dataset.rowClickSetup = 'true';
    
    // Handle both click and touch events for mobile compatibility
    const handleRowToggle = async (e) => {
      // Don't expand if clicking on copy button or other interactive elements
      if (e.target.closest('.copy-btn') || e.target.closest('button')) {
        return;
      }
      
      // Don't expand/collapse if clicking inside the details section
      if (e.target.closest('.system-details')) {
        return;
      }
      
      // Find the clicked row - only trigger on the main row, not details section
      const rowElement = e.target.closest('[data-system-id]');
      if (!rowElement) return;
      
      // Make sure we're not clicking inside the details section
      const systemRow = rowElement.closest('.system-row');
      if (!systemRow) return;
      
      // Check if click is inside details section
      const detailsSection = systemRow.querySelector('.system-details');
      if (detailsSection && detailsSection.contains(e.target)) {
        return;
      }
      
      const systemId = rowElement.dataset.systemId;
      
      if (detailsSection) {
        // Toggle visibility with animation
        const isExpanding = detailsSection.classList.contains('hidden');
        
        if (isExpanding) {
          // IMPORTANT: Close all other expanded sections first to prevent CPU overload
          // Only keep one section expanded at a time
          const allExpandedSections = container.querySelectorAll('.system-details:not(.hidden)');
          allExpandedSections.forEach(section => {
            // Skip the current section we're about to expand
            const sectionSystemRow = section.closest('.system-row');
            if (sectionSystemRow && sectionSystemRow.querySelector('[data-system-id]') !== rowElement) {
              // Get the system ID for cleanup
              const otherRowElement = sectionSystemRow.querySelector('[data-system-id]');
              const otherSystemId = otherRowElement ? otherRowElement.dataset.systemId : null;
              
              // Cleanup tcping chart for this system
              if (otherSystemId) {
                cleanupTCPingChart(otherSystemId);
              }
              
              // Collapse this section
              section.style.maxHeight = section.scrollHeight + 'px';
              section.style.opacity = '1';
              section.offsetHeight; // Trigger reflow
              
              section.style.transition = 'max-height 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s ease-in';
              section.style.maxHeight = '0';
              section.style.opacity = '0';
              
              setTimeout(() => {
                section.classList.add('hidden');
                section.style.maxHeight = '';
                section.style.opacity = '';
                section.style.transition = '';
              }, 250);
              
              // Update aria-expanded attribute
              if (otherRowElement) {
                otherRowElement.setAttribute('aria-expanded', 'false');
              }
            }
          });
          
          // Expanding - show and animate in
          detailsSection.classList.remove('hidden');
          detailsSection.style.maxHeight = '0';
          detailsSection.style.opacity = '0';
          
          // Trigger reflow
          detailsSection.offsetHeight;
          
          // Initialize TCPing tabs and start animation in parallel for better UX
          // Start tabs initialization (don't wait)
          const tabsPromise = initializeTCPingTabs(systemId);
          
          // Start animation immediately to avoid perceived lag
          detailsSection.style.transition = 'max-height 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.25s ease-out';
          // Use a reasonable estimated height, it will adjust as content loads
          detailsSection.style.maxHeight = '800px'; // Temporary max height
          detailsSection.style.opacity = '1';
          
          // Wait for tabs to finish loading, then adjust to actual height
          tabsPromise.then(() => {
            // Give DOM a moment to update
            requestAnimationFrame(() => {
              // Update to actual scroll height
              detailsSection.style.maxHeight = detailsSection.scrollHeight + 'px';
              
              // Clean up after animation completes
              setTimeout(() => {
                detailsSection.style.maxHeight = '';
                detailsSection.style.transition = '';
              }, 300);
            });
          });
          
          // Initialize tcping chart immediately (don't wait for animation)
          // Chart will load in parallel with the expansion animation
          setTimeout(() => initializeTCPingChart(systemId), 50);
          
          // Update translations when expanding
          setTimeout(() => updateTranslations(), 0);
          
          rowElement.setAttribute('aria-expanded', 'true');
        } else {
          // Collapsing - animate out then hide
          // Cleanup tcping chart for this system
          cleanupTCPingChart(systemId);
          
          detailsSection.style.maxHeight = detailsSection.scrollHeight + 'px';
          detailsSection.style.opacity = '1';
          
          // Trigger reflow
          detailsSection.offsetHeight;
          
          // Animate to zero
          detailsSection.style.transition = 'max-height 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s ease-in';
          detailsSection.style.maxHeight = '0';
          detailsSection.style.opacity = '0';
          
          // Hide after animation
          setTimeout(() => {
            detailsSection.classList.add('hidden');
            detailsSection.style.maxHeight = '';
            detailsSection.style.opacity = '';
            detailsSection.style.transition = '';
          }, 250);
          
          rowElement.setAttribute('aria-expanded', 'false');
        }
      }
    };
    
    // Use a simple approach: handle both touchstart and click, but prevent double-trigger
    let lastTouchTime = 0;
    let lastTouchTarget = null;
    
    // Track touch state to distinguish between tap and scroll
    let touchStartX = 0;
    let touchStartY = 0;
    let touchMoved = false;
    let touchTarget = null;
    let touchRowElement = null;
    
    // Handle touch events directly for mobile - distinguish between tap and scroll
    container.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      if (!touch) return;
      
      // Reset touch state
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchMoved = false;
      
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (!target) return;
      
      touchTarget = target;
      
      // Check if this is a row element
      const rowElement = target.closest('[data-system-id]');
      if (!rowElement) return;
      
      touchRowElement = rowElement;
      
      // Don't trigger if clicking on buttons
      if (target.closest('.copy-btn') || target.closest('button')) {
        touchTarget = null;
        touchRowElement = null;
        return;
      }
    }, { passive: true });
    
    // Detect if user is scrolling (not tapping)
    container.addEventListener('touchmove', (e) => {
      if (!touchTarget || !touchRowElement) return;
      
      const touch = e.touches[0];
      if (!touch) return;
      
      // Calculate movement distance
      const deltaX = Math.abs(touch.clientX - touchStartX);
      const deltaY = Math.abs(touch.clientY - touchStartY);
      
      // If moved more than 10px in any direction, consider it a scroll
      if (deltaX > 10 || deltaY > 10) {
        touchMoved = true;
        touchTarget = null;
        touchRowElement = null;
      }
    }, { passive: true });
    
    // Handle tap (only if no scrolling occurred)
    container.addEventListener('touchend', (e) => {
      if (!touchTarget || !touchRowElement || touchMoved) {
        touchTarget = null;
        touchRowElement = null;
        touchMoved = false;
        return;
      }
      
      const rowElement = touchRowElement;
      const target = touchTarget;
      
      // Reset touch state
      touchTarget = null;
      touchRowElement = null;
      touchMoved = false;
      
      // Prevent double-trigger: if we just handled a touch for this target, ignore click
      const now = Date.now();
      if (lastTouchTarget === rowElement && now - lastTouchTime < 500) {
        return;
      }
      
      lastTouchTime = now;
      lastTouchTarget = rowElement;
      
      // Create a synthetic event for handleRowToggle
      const syntheticEvent = {
        target: target,
        currentTarget: container,
        preventDefault: () => {},
        stopPropagation: () => {}
      };
      
      // Use setTimeout to ensure this happens after any potential click event
      setTimeout(() => {
        handleRowToggle(syntheticEvent);
      }, 50);
    }, { passive: true });
    
    // Handle click events (for desktop and as fallback)
    container.addEventListener('click', (e) => {
      // Skip if this was a touch event (prevent double-trigger)
      const now = Date.now();
      if (lastTouchTarget && now - lastTouchTime < 500) {
        const rowElement = e.target.closest('[data-system-id]');
        if (rowElement === lastTouchTarget) {
          lastTouchTime = 0;
          lastTouchTarget = null;
          return;
        }
      }
      
      handleRowToggle(e);
    });
  };
  
  // Smart render with incremental updates
  const render = async (items) => {
    if (!body) return;
    
    if (loadingIndicator) loadingIndicator.style.display = 'none';
    
    if (!items || items.length === 0) {
      showEmpty();
      currentData.clear();
      return;
    }
    
    // Check if tcping is configured before rendering
    let tcpingConfigured = false;
    try {
      const config = await loadTCPingConfig();
      tcpingConfigured = config && config.targets && config.targets.length > 0;
    } catch (err) {
      // Config check failed silently
    }
    
    // Create new data map with normalized items
    const newData = new Map();
    items.forEach(item => {
      const normalized = normalizeItem(item);
      normalized.original = item; // Keep original for rendering
      newData.set(item.id, normalized);
    });
    
    // Initial render - if no existing data, render everything
    if (currentData.size === 0) {
      body.innerHTML = items.map(item => renderRow(item, tcpingConfigured)).join('');
      currentData = newData;
      
      // Add staggered entrance animation for initial load
      const systemRows = body.querySelectorAll('.system-row');
      systemRows.forEach((row, index) => {
        row.style.opacity = '0';
        row.classList.add('animate-stagger-in');
        row.style.animationDelay = `${index * 50}ms`;
        // Clean up after animation
        setTimeout(() => {
          row.style.opacity = '';
          row.classList.remove('animate-stagger-in');
          row.style.animationDelay = '';
        }, 400 + index * 50);
      });
      
      await loadOSIcons();
      await loadFlagIcons();
      setupCopyButtons(body);
      setupRowClickHandlers(body);
      // Update translations after DOM is ready
      setTimeout(() => updateTranslations(), 0);
      // Calculate and set server name column width based on longest name
      setTimeout(() => adjustServerNameColumnWidth(), 0);
      return;
    }
    
    // Get existing rows - now looking for .system-row instead of [data-system-id]
    const existingRows = body.querySelectorAll('.system-row');
    const existingRowMap = new Map();
    existingRows.forEach(systemRow => {
      const rowElement = systemRow.querySelector('[data-system-id]');
      const id = rowElement?.dataset.systemId;
      if (id) {
        existingRowMap.set(id, rowElement);
      }
    });
    
    // Track which rows need updates
    let hasChanges = false;
    const rowsToUpdate = [];
    const rowsToAdd = [];
    const rowsToRemove = [];
    
    // Check for updates and new items
    items.forEach((item, index) => {
      const normalizedItem = newData.get(item.id);
      const oldItem = currentData.get(item.id);
      const existingRow = existingRowMap.get(item.id);
      
      if (!existingRow) {
        // New row needs to be added
        rowsToAdd.push({ item, index });
        hasChanges = true;
      } else if (hasChanged(oldItem, normalizedItem)) {
        // Existing row needs update - use original item for rendering
        rowsToUpdate.push({ row: existingRow, item: item });
        hasChanges = true;
      } else if (oldItem && oldItem.order !== normalizedItem.order) {
        // Order changed, need to reorder
        hasChanges = true;
      }
    });
    
    // Check for removed items
    currentData.forEach((oldItem, id) => {
      if (!newData.has(id)) {
        rowsToRemove.push(id);
        hasChanges = true;
      }
    });
    
    // Check if order changed (for sorting) - check BEFORE early return
    const currentOrder = Array.from(body.children).map(systemRow => {
      const rowElement = systemRow.querySelector('[data-system-id]');
      return rowElement?.dataset.systemId;
    }).filter(Boolean);
    const desiredOrder = items.map(item => item.id);
    const orderChanged = currentOrder.length === desiredOrder.length && 
                         JSON.stringify(currentOrder) !== JSON.stringify(desiredOrder);
    
    // Always update currentData first, before any DOM operations
    // This ensures that updateRow has access to the correct old data
    const previousData = new Map(currentData);
    currentData = newData;
    
    // If no changes AND order hasn't changed, skip update completely
    if (!hasChanges && !orderChanged && existingRows.length === items.length) {
      // Cache already updated above, just return
      return; // Silent skip - no DOM operations
    }
    
    // Remove deleted rows
    rowsToRemove.forEach(id => {
      const rowElement = existingRowMap.get(id);
      if (rowElement) {
        const systemRow = rowElement.closest('.system-row');
        if (systemRow) {
          systemRow.remove();
        } else {
          rowElement.remove();
        }
      }
    });
    
    // Update existing rows (only changed cells) - batch updates
    if (rowsToUpdate.length > 0) {
      rowsToUpdate.forEach(({ row, item }) => {
        // Get previous item data before updating
        const previousItem = previousData.get(item.id);
        updateRow(row, item, previousItem);
      });
      // Only load OS icons if OS changed
      const osChanged = rowsToUpdate.some(({ item }) => {
        const old = currentData.get(item.id);
        return old && old.os_icon !== item.os_icon;
      });
      if (osChanged) {
        setTimeout(() => loadOSIcons(), 0);
      }
      
      // Load flag icons if location changed
      const locationChanged = rowsToUpdate.some(({ item }) => {
        const old = currentData.get(item.id);
        return old && old.location !== item.location;
      });
      if (locationChanged) {
        setTimeout(() => loadFlagIcons(), 0);
      }
    }
    
    // Add new rows
    if (rowsToAdd.length > 0) {
      rowsToAdd.forEach(({ item, index }, addIndex) => {
        // Find insertion point
        let insertBefore = null;
        for (let i = index + 1; i < items.length; i++) {
          const nextId = items[i].id;
          const nextRow = body.querySelector(`[data-system-id="${nextId}"]`);
          if (nextRow) {
            insertBefore = nextRow;
            break;
          }
        }
        
        // Use cached tcping config status or check if needed
        const rowHTML = renderRow(item, tcpingConfigured);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rowHTML;
        const systemRowElement = tempDiv.firstElementChild;
        if (systemRowElement) {
          // Add entrance animation for new rows
          systemRowElement.classList.add('animate-scale-in');
          systemRowElement.style.animationDelay = `${addIndex * 50}ms`;
          
          // Find the system-row to insert before
          let insertBeforeSystemRow = null;
          if (insertBefore) {
            insertBeforeSystemRow = insertBefore.closest('.system-row');
          }
          if (insertBeforeSystemRow) {
            body.insertBefore(systemRowElement, insertBeforeSystemRow);
          } else {
            body.appendChild(systemRowElement);
          }
          
          // Clean up animation class after animation completes
          setTimeout(() => {
            systemRowElement.classList.remove('animate-scale-in');
            systemRowElement.style.animationDelay = '';
          }, 300 + addIndex * 50);
        }
      });
      
      await loadOSIcons();
      await loadFlagIcons();
      setupCopyButtons(body);
      setupRowClickHandlers(body);
      // Update translations after DOM is ready
      setTimeout(() => updateTranslations(), 0);
      // Calculate and set server name column width based on longest name
      setTimeout(() => adjustServerNameColumnWidth(), 0);
    }
    
    // Handle reordering if needed - ALWAYS check order, even if no other changes
    // This ensures sorting works correctly
    if (orderChanged) {
      // Reorder rows without full re-render
      const rowMap = new Map();
      Array.from(body.children).forEach(systemRow => {
        const rowElement = systemRow.querySelector('[data-system-id]');
        const id = rowElement?.dataset.systemId;
        if (id) {
          rowMap.set(id, systemRow);
        }
      });
      
      // Re-append in correct order
      items.forEach(item => {
        const row = rowMap.get(item.id);
        if (row && row.parentNode) {
          body.appendChild(row); // appendChild moves existing element
        }
      });
    }
    
    // Cache already updated at the beginning of the function
    
    // Recalculate server name column width after any DOM changes
    setTimeout(() => adjustServerNameColumnWidth(), 0);
  };

  // Fetch data from backend - ONLY source of truth
  async function loadData() {
    try {
      const data = await fetchSystemMetrics(apiBase);
      
      if (data.length === 0) {
        showEmpty();
      } else {
        // Apply filter first, then sorting
        const filteredData = filterSystems(data);
        const sortedData = sortSystems(filteredData);
        await render(sortedData);
      }
    } catch (err) {
      if (loadingIndicator) {
        loadingIndicator.innerHTML = `
          <div class="text-center">
            <p class="text-sm text-red-400">Failed to connect to backend</p>
            <p class="text-xs text-[#525252] dark:text-[#525252] text-[#737373] mt-1">${err.message}</p>
          </div>
        `;
      }
    }
  }

  // Debounce loadData to prevent duplicate updates
  let loadDataTimeout = null;
  let isLoadDataRunning = false; // Flag to prevent concurrent loadData calls
  const debouncedLoadData = () => {
    // If loadData is already running, skip this call
    if (isLoadDataRunning) {
      return;
    }
    
    if (loadDataTimeout) {
      clearTimeout(loadDataTimeout);
    }
    loadDataTimeout = setTimeout(async () => {
      if (isLoadDataRunning) {
        return; // Double check before executing
      }
      isLoadDataRunning = true;
      try {
        await loadData();
      } finally {
        isLoadDataRunning = false;
        loadDataTimeout = null;
      }
    }, 200); // 200ms debounce - prevents rapid consecutive calls
  };

  // Connect to SSE for real-time updates
  function connectSSE() {
    // Close existing connection and remove all event listeners
    if (eventSource) {
      eventSource.close();
      eventSource = null;
    }

    // Get token from URL parameter (for share links) or admin token
    const urlParams = new URLSearchParams(window.location.search);
    const shareToken = urlParams.get('token');
    const adminToken = localStorage.getItem('admin_auth_token');
    
    // Build SSE URL with token if available (EventSource doesn't support custom headers)
    let sseUrl = `${apiBase}/api/events`;
    if (shareToken) {
      sseUrl += `?token=${encodeURIComponent(shareToken)}`;
    } else if (adminToken) {
      // For admin token, we need to pass it via URL since EventSource doesn't support headers
      // Note: This is less secure, but EventSource limitation
      sseUrl += `?admin_token=${encodeURIComponent(adminToken)}`;
    }

    eventSource = new EventSource(sseUrl);

    eventSource.addEventListener('connected', (e) => {
      // Connected to update stream
    });

    // Store the handler function so we can remove it if needed
    const updateHandler = (e) => {
      try {
        const update = JSON.parse(e.data);
        
        // Reload data when any update is received (incremental update will handle changes)
        if (update.type === 'metric_updated' || update.type === 'order_updated' || update.type === 'metric_deleted') {
          // Use debounced loadData to prevent duplicate updates from rapid SSE events
          debouncedLoadData();
          
          // Update tcping charts for visible expanded rows (incremental update only)
          // Note: Due to our single-expand policy, there should only be max 1 expanded section
          const expandedSections = document.querySelectorAll('.system-details:not(.hidden)');
          expandedSections.forEach(detailsSection => {
            const systemId = detailsSection.dataset.detailsId;
            if (systemId) {
              // Check if this system is not currently loading (to avoid conflicts)
              const loadingState = tcpingLoadingStates.get(systemId);
              if (!loadingState || !loadingState.loading) {
                // Use incremental update for all targets chart
                updateTCPingChart(systemId, null, null, true);
              }
            }
          });
        }
      } catch (err) {
        // SSE parse error silently
      }
    };
    
    eventSource.addEventListener('update', updateHandler);

    eventSource.onerror = (err) => {
      if (eventSource) {
      eventSource.close();
        eventSource = null;
      }
      // Reconnect after 5 seconds
      setTimeout(connectSSE, 5000);
    };
  }

  // Setup filter input handler - prevent duplicate event listeners
  let filterInputHandlersSetup = false;
  function setupFilterInput() {
    const filterInput = document.getElementById('system-filter-input');
    if (!filterInput || filterInputHandlersSetup) return; // Already setup, skip

    const inputHandler = (e) => {
      currentFilter = e.target.value;
      // Reload data to apply filter
      loadData();
    };

    const keydownHandler = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        currentFilter = e.target.value;
        loadData();
      }
    };

    filterInput.addEventListener('input', inputHandler);
    filterInput.addEventListener('keydown', keydownHandler);
    filterInputHandlersSetup = true;
  }

  // Initial load - wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setupFilterInput();
      loadData();
      connectSSE();
      // Initial translation update
      updateTranslations();
      // Preload TCPing config for faster tab display
      preloadTCPingConfig();
    });
  } else {
    setupFilterInput();
    loadData();
    connectSSE();
    // Initial translation update
    updateTranslations();
    // Preload TCPing config for faster tab display
    preloadTCPingConfig();
  }

  // Cleanup on page unload
  // Recalculate column width on window resize (with debounce)
  let resizeTimeout = null;
  window.addEventListener('resize', () => {
    if (resizeTimeout) {
      clearTimeout(resizeTimeout);
    }
    resizeTimeout = setTimeout(() => {
      adjustServerNameColumnWidthDebounced();
      resizeTimeout = null;
    }, 250);
  });

  window.addEventListener('beforeunload', () => {
    if (eventSource) {
      eventSource.close();
    }
  });
</script>